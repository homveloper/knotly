# Markdown Split Editor with Mind Map - 사용자 요구사항 명세

## 목표

사용자가 키보드로 빠르게 마크다운 텍스트를 입력하면서도 시각적으로 마인드맵 구조를 동시에 확인할 수 있는 하이브리드 노트 도구를 제공한다. 기존 마인드맵 도구는 마우스/터치 중심으로 입력 속도가 느리다는 한계를 극복하고, 표준 마크다운 문법을 완전히 호환하여 다른 도구(Obsidian, Notion, Git 등)와 자유롭게 연동할 수 있도록 한다.

## 핵심 기능

사용자는 화면 좌측 마크다운 에디터에서 텍스트를 입력하면 우측 마인드맵 캔버스에 실시간으로 노드와 엣지가 자동 생성되는 것을 확인할 수 있다. 반대로 우측 캔버스에서 노드를 드래그하거나 편집하면 좌측 에디터의 마크다운 텍스트가 자동으로 업데이트된다. 헤더 레벨(`#`, `##`, `###`)과 리스트 들여쓰기로 계층 관계를 표현하며, 계층 관계 외 추가 연결은 캔버스의 링크 버튼(🔗)으로 생성할 수 있다(마크다운에는 저장되지 않음). 코드 블록과 이미지도 각각 독립적인 노드로 렌더링되며, `{.color-red .h3}` 같은 스타일 토큰으로 노드 색상과 크기를 지정할 수 있다. 분할 화면의 비율은 사용자가 드래그로 자유롭게 조절 가능하며(30%-70% 범위), 설정은 자동 저장된다. 캔버스 상단의 레이아웃 버튼(🌟 Radial, ➡️ Horizontal)으로 노드 배치 방식을 선택할 수 있으며, 선택한 레이아웃은 마크다운 파일에 `<!-- knotly-layout: radial -->` 형식으로 저장되어 다음 로드 시에도 유지된다.

## 입출력 명세

**입력**: 순수 마크다운 텍스트 파일(`.md` 확장자). 파일 최상단에 `<!-- knotly-layout: radial -->` 또는 `<!-- knotly-layout: horizontal -->` HTML 주석으로 레이아웃 타입을 지정할 수 있으며(생략 시 기본값 `radial`), 헤더, 리스트, 코드 블록, 이미지, 수평선(`---`) 구분자를 포함할 수 있다. 각 요소 뒤에 `{.token1 .token2}` 형식의 스타일 토큰을 추가할 수 있다. 계층 외 추가 연결은 마크다운에 표현되지 않고 캔버스 UI에서 생성한다.

**출력**: 입력과 동일한 순수 마크다운 파일. 캔버스에서 레이아웃을 변경하면 파일 최상단의 `<!-- knotly-layout: ... -->` 주석이 업데이트된다. 노드를 편집하거나 이동해도 마크다운 구조가 보존되며, 노드 스타일과 연결 관계가 마크다운 문법으로 정확히 직렬화된다. 파일은 Git diff/merge가 가능하고, 다른 마크다운 도구에서는 HTML 주석이 무시되어 순수 마크다운으로 읽힌다.

## 데이터 구조

애플리케이션 내부에서는 Node 배열과 Edge 배열로 그래프를 표현한다. 각 Node는 `id`, `type`(text/header/code/image), `content`, `level`(헤더 레벨 또는 리스트 깊이), `style`(토큰 문자열), `position`(x, y 좌표), `measuredSize`(실제 렌더링된 width, height), `groupId`(수평선 구분자로 묶인 그룹 식별자)를 가진다. 코드 노드는 `language`와 코드 원본을, 이미지 노드는 `imageUrl`과 `altText`를 추가로 가진다. Edge는 `sourceId`와 `targetId`로 노드 간 연결을 나타내며, 계층 관계(헤더 레벨, 리스트 들여쓰기)와 캔버스에서 생성한 자유 연결을 모두 포함한다. 코드 블록과 이미지는 바로 위에 있는 헤더 또는 리스트 항목의 자식으로 자동 연결되며, 파일 최상단에 있는 경우 부모 없는 루트 노드가 된다. 레이아웃 타입(`radial` 또는 `horizontal`)은 별도로 관리되며, 파일 로드 시 HTML 주석에서 파싱하고 파싱된 노드들의 위치는 선택된 레이아웃 알고리즘에 따라 자동으로 계산된다. 노드 위치는 각 노드의 실제 크기(measuredSize)를 기반으로 계산되어 노드 간 충돌이 수학적으로 발생하지 않도록 보장된다.

## 기능적 제약사항

마크다운 텍스트 변경은 300ms debounce 처리되어 실시간 파싱 성능을 확보한다. 에디터와 캔버스 간 순환 업데이트를 방지하기 위해 dirty 플래그를 사용하여 한쪽에서 변경이 발생하면 다른 쪽의 자동 업데이트를 일시 중단한다. 에디터에서 텍스트를 수정할 때 현재 커서 위치를 기억하여 캔버스 업데이트 후에도 커서가 이동하지 않도록 보존한다. 분할 화면 비율은 30%-70% 범위로 제한되며, LocalStorage에 저장되어 재접속 시 복원된다. 순수 마크다운으로 표현 가능한 구조만 지원하며, YAML frontmatter와 `.knotly` 확장자는 완전히 제거된다. 노드 위치는 마크다운에 저장되지 않고 선택된 레이아웃 알고리즘에 따라 자동으로 계산되므로, 사용자가 캔버스에서 노드를 드래그해도 파일 저장 시 위치는 반영되지 않는다(다음 로드 시 레이아웃 알고리즘으로 재계산).

## 완료 조건

사용자가 좌측 에디터에 마크다운 텍스트를 입력하면 우측 캔버스에 헤더, 리스트, 코드 블록, 이미지가 각각 올바른 타입의 노드로 렌더링되고, 헤더 레벨과 리스트 들여쓰기에 따라 부모-자식 엣지가 자동으로 생성되어야 한다. 반대로 캔버스에서 노드를 드래그, 편집, 삭제하면 에디터의 마크다운 텍스트가 즉시 업데이트되어야 한다. `{.color-red .h3}` 같은 스타일 토큰이 노드 색상과 크기에 정확히 반영되어야 한다. 코드 블록은 미리보기 상태와 확장 상태를 토글할 수 있으며, 이미지는 썸네일로 렌더링되어야 한다. 분할 화면 비율을 드래그로 조절할 수 있고, 파일 저장/로드 시 순수 `.md` 파일로 읽고 쓸 수 있어야 한다. 캔버스 상단의 레이아웃 버튼(🌟 Radial, ➡️ Horizontal)으로 레이아웃을 전환할 수 있으며, 전환 시 모든 노드가 선택된 레이아웃 알고리즘에 따라 재배치되어야 한다. 파일에 `<!-- knotly-layout: ... -->` 주석이 올바르게 저장되고, 다음 로드 시 저장된 레이아웃이 복원되어야 한다. 모든 기능이 정상 동작하며, 순환 업데이트가 발생하지 않고, 커서 위치가 보존되어야 한다.
