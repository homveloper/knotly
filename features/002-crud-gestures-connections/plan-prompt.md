기술 스택: React 18을 프론트엔드 프레임워크로 사용한다. TypeScript로 타입 안전성을 확보한다. Zustand를 상태 관리 라이브러리로 채택하여 경량화하고, Redux보다 간단한 API를 활용한다. @use-gesture/react(이전 react-use-gesture)를 터치 제스처 라이브러리로 사용하여 핀치, 팬, 드래그를 구현한다. Tailwind CSS를 스타일링 도구로 사용하여 유틸리티 클래스 기반의 빠른 UI 개발을 지원한다. rough.js는 Milestone 1에서 이미 설치되어 있으므로 재사용한다. uuid 라이브러리를 추가하여 노드와 엣지의 고유 ID를 생성한다.

아키텍처 개요: Zustand 스토어를 src/store/canvasStore.ts에 생성하여 노드 배열, 엣지 배열, 줌 레벨, 팬 오프셋, 그리드 설정을 관리한다. Canvas 컴포넌트는 Milestone 1의 정적 렌더링을 리팩토링하여 useCanvasStore 훅으로 상태를 구독하고 map으로 여러 노드를 렌더링한다. FAB 버튼 컴포넌트(FABButton.tsx)를 별도로 분리하여 createNode 액션을 호출한다. ContextMenu 컴포넌트(ContextMenu.tsx)를 만들어 바텀시트 형태로 배경색 변경과 삭제 옵션을 제공한다. MentionSheet 컴포넌트(MentionSheet.tsx)를 만들어 @ 입력 시 노드 목록을 바텀시트로 표시한다. GridBackground 컴포넌트(GridBackground.tsx)를 만들어 SVG line 요소로 그리드를 렌더링한다. @use-gesture/react의 useGesture 훅을 Canvas 컴포넌트에서 사용하여 핀치, 팬, 드래그를 처리한다.

Zustand 설치 및 스토어 생성. pnpm add zustand uuid와 pnpm add -D @types/uuid를 실행한다. src/store/canvasStore.ts 파일을 생성하고 create 함수를 import한다. import {create} from 'zustand'를 추가한다. 노드 타입과 엣지 타입을 정의한다. type Node = {id: string; position: {x: number; y: number}; content: string; type: 'circle'; style: {backgroundColor: string; strokeColor: string; strokeWidth: number}; createdAt: number; updatedAt: number}; type Edge = {id: string; fromId: string; toId: string; lineStyle: 'dashed'; createdAt: number}를 작성한다. 스토어 인터페이스를 정의한다. interface CanvasStore {nodes: Node[]; edges: Edge[]; zoom: number; pan: {x: number; y: number}; gridEnabled: boolean; snapEnabled: boolean; createNode: (position: {x: number; y: number}) => void; updateNode: (id: string, content: string) => void; moveNode: (id: string, position: {x: number; y: number}) => void; deleteNode: (id: string) => void; createEdge: (fromId: string, toId: string) => void; deleteEdge: (id: string) => void; setZoom: (zoom: number) => void; setPan: (pan: {x: number; y: number}) => void; toggleGrid: () => void; toggleSnap: () => void}를 작성한다. useCanvasStore를 create로 생성하고 초기 상태와 액션을 구현한다.

액션 구현. createNode 액션은 uuid를 사용하여 새 노드 ID를 생성하고 nodes 배열에 추가한다. const createNode = (position: {x: number; y: number}) => set((state) => ({nodes: [...state.nodes, {id: v4(), position, content: '', type: 'circle', style: {backgroundColor: '#FFE082', strokeColor: '#000', strokeWidth: 2}, createdAt: Date.now(), updatedAt: Date.now()}]}))를 작성한다. updateNode는 id로 노드를 찾아 content와 updatedAt을 업데이트한다. set((state) => ({nodes: state.nodes.map(n => n.id === id ? {...n, content, updatedAt: Date.now()} : n)}))를 작성한다. moveNode는 position을 업데이트하고 snapEnabled가 true이면 20px 단위로 스냅한다. deleteNode는 노드를 삭제하고 해당 노드와 연결된 모든 엣지도 삭제한다. set((state) => ({nodes: state.nodes.filter(n => n.id !== id), edges: state.edges.filter(e => e.fromId !== id && e.toId !== id)}))를 작성한다. createEdge는 uuid로 새 엣지 ID를 생성하고 edges 배열에 추가한다. deleteEdge는 id로 엣지를 찾아 삭제한다. setZoom은 zoom 값을 0.5에서 3 사이로 클램핑한다. setPan은 pan 값을 업데이트한다. toggleGrid와 toggleSnap은 boolean을 반전한다.

Canvas 컴포넌트 리팩토링. Milestone 1의 Canvas.tsx를 수정하여 useCanvasStore에서 nodes를 가져온다. const {nodes, edges, zoom, pan} = useCanvasStore()를 추가한다. nodes.map으로 각 노드를 렌더링한다. {nodes.map(node => <NodeComponent key={node.id} node={node} />)}를 작성한다. NodeComponent를 별도 컴포넌트로 분리하여 rough.js로 동그라미를 그리고 SVG text로 content를 렌더링한다. NodeComponent에서 @use-gesture/react의 useDrag 훅을 사용하여 드래그를 처리한다. const bind = useDrag(({offset: [x, y]}) => moveNode(node.id, {x, y}))를 추가하고 SVG g 태그에 {...bind()}를 spread한다. zoom과 pan을 SVG transform 속성에 적용한다. svg 태그에 transform={`translate(${pan.x}, ${pan.y}) scale(${zoom})`}를 추가한다.

FAB 버튼 구현. src/components/FABButton.tsx 파일을 생성한다. Tailwind CSS로 스타일링한다. button className="fixed bottom-4 right-4 w-14 h-14 bg-blue-500 text-white rounded-full shadow-lg flex items-center justify-center text-2xl"를 작성한다. onClick 핸들러에서 createNode를 호출한다. const {createNode} = useCanvasStore()를 추가하고 onClick={() => createNode({x: 400, y: 300})}를 설정한다. 현재 뷰포트 중심 좌표를 계산하려면 zoom과 pan을 고려해야 한다. const center = {x: (window.innerWidth / 2 - pan.x) / zoom, y: (window.innerHeight / 2 - pan.y) / zoom}를 계산하여 createNode(center)를 호출한다. App.tsx에서 FABButton 컴포넌트를 import하고 Canvas와 함께 렌더링한다.

제스처 구현. @use-gesture/react를 설치한다. pnpm add @use-gesture/react를 실행한다. Canvas 컴포넌트에서 useGesture 훅을 사용한다. import {useGesture} from '@use-gesture/react'를 추가한다. useGesture({onPinch: ({offset: [scale]}) => setZoom(scale), onDrag: ({delta: [dx, dy], touches}) => {if (touches > 1) setPan({x: pan.x + dx, y: pan.y + dy})}})를 설정한다. bind를 svg 태그에 spread한다. svg {...bind()}를 추가한다. 핀치는 두 손가락 간 거리 변화로 감지되며, offset[0]이 스케일 값이다. 팬은 터치가 2개 이상일 때만 활성화한다. touches > 1 조건을 확인한다. 노드 드래그와 캔버스 팬을 구분하기 위해 터치 수를 확인한다.

컨텍스트 메뉴 구현. src/components/ContextMenu.tsx 파일을 생성한다. props로 nodeId, position, onClose를 받는다. interface ContextMenuProps {nodeId: string; position: {x: number; y: number}; onClose: () => void}를 정의한다. 바텀시트 형태로 렌더링한다. div className="fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl shadow-2xl p-4"를 작성한다. 배경색 변경 옵션을 3개 표시한다. 각 색상을 버튼으로 렌더링하고 onClick에서 updateNode를 호출한다. const {updateNode} = useCanvasStore()를 추가하고 onClick={() => updateNode(nodeId, {style: {backgroundColor: '#90CAF9'}})}를 설정한다. 삭제 버튼을 추가하고 onClick에서 deleteNode를 호출한다. const {deleteNode} = useCanvasStore()를 추가하고 onClick={() => {deleteNode(nodeId); onClose()}}를 설정한다. NodeComponent에서 롱프레스를 감지한다. @use-gesture/react의 useLongPress 훅 또는 setTimeout을 사용한다. 롱프레스 시 ContextMenu를 표시하는 상태를 관리한다. const [showMenu, setShowMenu] = useState(false)를 추가하고 조건부 렌더링한다.

연결선 구현. EdgeComponent.tsx 파일을 생성한다. props로 edge를 받고 fromId와 toId로 노드를 찾아 위치를 계산한다. const {nodes} = useCanvasStore()를 추가하고 const fromNode = nodes.find(n => n.id === edge.fromId), const toNode = nodes.find(n => n.id === edge.toId)를 계산한다. rough.js의 line 메서드로 점선을 그린다. const rc = rough.svg(svgRef.current), const line = rc.line(fromNode.position.x, fromNode.position.y, toNode.position.x, toNode.position.y, {strokeLineDash: [5, 5], strokeWidth: 2, stroke: '#666'})를 작성하고 appendChild한다. Canvas 컴포넌트에서 edges.map으로 EdgeComponent를 렌더링한다. {edges.map(edge => <EdgeComponent key={edge.id} edge={edge} />)}를 추가한다. 연결 모드 버튼을 구현한다. useState로 연결 모드 상태를 관리한다. const [connectMode, setConnectMode] = useState(false), const [firstNodeId, setFirstNodeId] = useState<string | null>(null)를 추가한다. 버튼을 클릭하면 connectMode를 true로 설정한다. 노드를 클릭하면 firstNodeId가 null이면 설정하고, null이 아니면 createEdge를 호출한다. if (!firstNodeId) setFirstNodeId(node.id) else {createEdge(firstNodeId, node.id); setFirstNodeId(null); setConnectMode(false)}를 작성한다.

멘션 구현. src/components/MentionSheet.tsx 파일을 생성한다. props로 currentNodeId, onSelect, onClose를 받는다. interface MentionSheetProps {currentNodeId: string; onSelect: (nodeId: string) => void; onClose: () => void}를 정의한다. useCanvasStore에서 nodes를 가져와 필터링한다. const {nodes} = useCanvasStore(), const filteredNodes = nodes.filter(n => n.id !== currentNodeId)를 계산한다. 바텀시트 형태로 노드 목록을 렌더링한다. div className="fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl shadow-2xl p-4 max-h-64 overflow-y-auto"를 작성한다. 각 노드를 버튼으로 렌더링하고 onClick에서 onSelect를 호출한다. {filteredNodes.map(node => <button key={node.id} onClick={() => onSelect(node.id)} className="block w-full text-left p-2 hover:bg-gray-100">{node.content}</button>)}를 작성한다. NodeComponent의 텍스트 입력 핸들러에서 @ 감지를 구현한다. onChange={(e) => {const value = e.target.value; if (value.endsWith('@')) setShowMentionSheet(true); updateNode(node.id, value)}}를 작성한다. MentionSheet의 onSelect에서 createEdge를 호출한다. onSelect={(targetId) => {createEdge(currentNodeId, targetId); setShowMentionSheet(false)}}를 설정한다.

그리드 배경 구현. src/components/GridBackground.tsx 파일을 생성한다. props로 width, height, spacing, enabled를 받는다. interface GridBackgroundProps {width: number; height: number; spacing: number; enabled: boolean}를 정의한다. enabled가 false이면 null을 반환한다. if (!enabled) return null를 추가한다. SVG line 요소를 반복하여 그리드를 그린다. useMemo로 line 배열을 메모이제이션한다. const lines = useMemo(() => {const result = []; for (let i = 0; i < width; i += spacing) result.push(<line key={`v${i}`} x1={i} y1={0} x2={i} y2={height} stroke="#e5e5e5" strokeWidth={1} />); for (let j = 0; j < height; j += spacing) result.push(<line key={`h${j}`} x1={0} y1={j} x2={width} y2={j} stroke="#e5e5e5" strokeWidth={1} />); return result}, [width, height, spacing])를 작성한다. g 태그로 감싸서 반환한다. return <g>{lines}</g>를 작성한다. Canvas 컴포넌트에서 GridBackground를 렌더링한다. const {gridEnabled} = useCanvasStore()를 추가하고 <GridBackground width={2000} height={2000} spacing={20} enabled={gridEnabled} />를 추가한다.

기술적 제약사항: Zustand의 persist 미들웨어는 사용하지 않는다. 이 단계에서는 데이터가 휘발성이어도 무방하다. Milestone 3에서 백엔드 저장을 구현한다. @use-gesture/react의 useGesture는 React 18의 concurrent mode와 호환되므로 별도 설정 없이 사용 가능하다. rough.js의 line 메서드는 매번 호출 시 랜덤한 떨림을 생성하므로 엣지가 다시 렌더링될 때마다 모양이 약간 바뀐다. 이를 방지하려면 seed 옵션을 사용한다. {seed: edge.id.hashCode()}와 같이 설정하여 동일한 엣지는 항상 동일한 모양으로 렌더링되도록 한다. 그리드 line 개수가 200개 이상이므로 useMemo로 메모이제이션하지 않으면 렌더링 성능이 저하될 수 있다. 핀치 제스처와 노드 드래그가 충돌하지 않도록 터치 수를 확인한다. 터치가 1개일 때만 노드 드래그가 활성화되고, 2개 이상일 때는 핀치 또는 팬이 우선한다.

참고 자료: Zustand 공식 문서 https://github.com/pmndrs/zustand에서 create 함수 사용법과 액션 패턴을 확인한다. TypeScript 타입 추론이 자동으로 작동하므로 별도 타입 정의가 필요 없다. @use-gesture/react 공식 문서 https://use-gesture.netlify.app/에서 useGesture 훅의 옵션을 확인한다. onPinch는 두 손가락 간 거리 변화를 감지하며, offset[0]이 스케일 값이다. onDrag의 touches 속성으로 터치 개수를 확인할 수 있다. Tailwind CSS 공식 문서 https://tailwindcss.com/docs에서 유틸리티 클래스를 확인한다. fixed, bottom-4, right-4는 우하단 고정 배치를 의미한다. rough.js의 seed 옵션은 공식 문서 https://github.com/rough-stuff/rough#options에서 확인한다. seed는 난수 생성의 시드 값으로, 동일한 seed는 동일한 결과를 생성한다.
