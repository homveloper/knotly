목표: 서버 주도 operation ordering 방식으로 실시간 협업을 구현한다. gRPC Server Streaming으로 워크스페이스의 변경사항을 실시간으로 푸시하고, Optimistic UI + Server Reconciliation 패턴으로 부드러운 사용자 경험을 제공하며, 이벤트 소싱으로 완벽한 히스토리 추적을 구현한다. 계정 시스템 없이 브라우저 세션 ID 또는 임시 닉네임으로 사용자를 식별하여 마찰 없는 협업을 지원한다.

핵심 기능: 서버 주도 operation ordering. 클라이언트가 operation(노드 이동, 수정, 삭제 등)을 gRPC Unary RPC로 서버에 전송하면, 서버는 sequence number를 부여하고 PostgreSQL workspace_events 테이블에 기록한 후 다른 모든 클라이언트에게 gRPC Server Streaming으로 broadcast한다. 서버는 각 operation의 순서를 결정하며, 클라이언트는 이 순서대로 Zustand 스토어를 업데이트하여 캔버스에 즉시 반영한다. 충돌 해결. 동일 노드를 두 사용자가 동시에 이동하면 마지막 timestamp를 가진 operation이 우선한다(Last Write Wins). 삭제된 노드를 수정하려는 operation은 서버에서 자동으로 무시하고 클라이언트에게 실패 응답을 보낸다. 존재하지 않는 노드에 엣지를 생성하려는 시도도 마찬가지로 실패 처리한다. Optimistic UI. 사용자가 노드를 이동하면 즉시 로컬 상태를 업데이트하고, 동시에 gRPC Unary RPC로 서버에 요청을 전송한다. 서버 응답이 실패하면 로컬 상태를 롤백하고 사용자에게 알림을 표시한다. 성공하면 그대로 유지한다. 500ms 디바운싱을 적용하여 드래그 중에는 요청을 보내지 않고, 드래그가 끝난 후 최종 위치만 전송한다. 이벤트 소싱. 서버는 승인된 모든 operation을 workspace_events 테이블에 sequence number, timestamp, session_id와 함께 저장한다. 매일 자정 스냅샷을 생성하고 7일 이전 이벤트는 자동 삭제하여 DB 크기를 관리한다. 워크스페이스 로드 시 최신 스냅샷 + 이후 이벤트만 재생하여 현재 상태를 복원한다. 사용자 식별. 브라우저 접속 시 UUID를 생성하여 localStorage에 저장하고, 모든 gRPC 요청에 메타데이터로 포함한다. 사용자는 선택적으로 임시 닉네임을 설정할 수 있으며, 설정하지 않으면 "익명 사용자 1234"와 같이 무작위 번호가 부여된다. 커서 위치 공유. 각 사용자의 마우스 또는 터치 위치를 다른 사용자에게 표시한다. CursorMovedEvent를 100ms 쓰로틀링하여 전송하고, 수신된 커서는 반투명 원과 사용자 닉네임으로 렌더링한다. 5초간 움직임이 없으면 커서를 페이드아웃시킨다.

입출력 명세: Protobuf 스키마. knotly.proto 파일에 Node, Edge, Workspace 메시지와 RPC를 정의한다. message Node {string id = 1; double x = 2; double y = 3; string content = 4; string type = 5; Style style = 6; int64 created_at = 7; int64 updated_at = 8;} message Edge {string id = 1; string from_id = 2; string to_id = 3; string line_style = 4; int64 created_at = 5;} message WorkspaceUpdate {int64 sequence_number = 1; int64 timestamp = 2; string session_id = 3; oneof operation {NodeCreated node_created = 10; NodeMoved node_moved = 11; NodeUpdated node_updated = 12; NodeDeleted node_deleted = 13; EdgeCreated edge_created = 14; EdgeDeleted edge_deleted = 15;}} service WorkspaceService {rpc CreateNode(CreateNodeRequest) returns (CreateNodeResponse); rpc MoveNode(MoveNodeRequest) returns (MoveNodeResponse); rpc UpdateNode(UpdateNodeRequest) returns (UpdateNodeResponse); rpc DeleteNode(DeleteNodeRequest) returns (DeleteNodeResponse); rpc StreamWorkspaceUpdates(StreamRequest) returns (stream WorkspaceUpdate);} gRPC Unary RPC. CreateNode 요청은 {workspace_id: UUID, position: {x: number, y: number}, content: string}를 전송하고, 응답은 {node_id: UUID, sequence_number: number}를 받는다. MoveNode 요청은 {node_id: UUID, position: {x: number, y: number}}를 전송하고, 응답은 {success: boolean, sequence_number: number} 또는 {success: false, error: string}를 받는다. gRPC Server Streaming. StreamWorkspaceUpdates 요청은 {workspace_id: UUID, session_id: UUID}를 전송하고, 서버는 해당 워크스페이스의 모든 변경사항을 stream으로 푸시한다. 클라이언트는 onData 콜백에서 WorkspaceUpdate 메시지를 수신하고, sequence_number 순서대로 처리한다. 커서 이벤트. CursorMoved 메시지는 {session_id: UUID, nickname: string, position: {x: number, y: number}, timestamp: number}를 전송한다. 100ms 쓰로틀링을 클라이언트에서 적용한다. 데이터베이스 스키마. workspace_events 테이블은 {id: UUID, workspace_id: UUID, sequence_number: BIGSERIAL, operation_type: VARCHAR, operation_data: JSONB, session_id: UUID, timestamp: BIGINT, created_at: TIMESTAMP} 구조를 가진다. workspace_snapshots 테이블은 {id: UUID, workspace_id: UUID, snapshot_data: JSONB, snapshot_at: TIMESTAMP, event_sequence_number: BIGINT} 구조를 가진다.

기능적 제약사항: 모든 워크스페이스가 공개되어 있다. 모든 사용자가 모든 워크스페이스에 접근하고 편집할 수 있으므로 권한 체크는 수행하지 않는다. 계정 시스템이 없다. 세션 ID는 localStorage에 저장되며, 브라우저를 닫으면 손실된다. 닉네임도 세션 동안만 유지된다. Undo/Redo는 구현하지 않는다. Phase 2에서 클라이언트 in-memory command stack으로 구현한다. Time Travel은 구현하지 않는다. Phase 2에서 서버 스냅샷을 활용하여 구현한다. 워크스페이스 소유권은 없다. 모든 사용자가 동등한 권한을 가진다. 오프라인 모드는 지원하지 않는다. 네트워크가 끊기면 재연결 시도만 한다.

기술적 제약: NestJS + gRPC를 백엔드로 사용한다. @nestjs/microservices와 @grpc/grpc-js 패키지를 설치한다. Protobuf 스키마는 protoc 컴파일러로 TypeScript 코드를 자동 생성한다. @grpc/proto-loader를 사용하여 .proto 파일을 로딩한다. 순수 PostgreSQL을 사용한다. pg 라이브러리로 SQL을 직접 작성한다. Connection Pool은 max 100으로 설정한다. 트랜잭션은 BEGIN, COMMIT, ROLLBACK을 직접 실행한다. Envoy 프록시를 사용한다. 8080 포트에서 gRPC-Web 요청을 받아 백엔드의 gRPC 서버(50051 포트)로 전달한다. envoy.yaml 파일을 작성하여 Docker Compose로 실행한다. 프론트엔드는 grpc-web 패키지를 사용한다. @improbable-eng/grpc-web를 설치하고, protoc-gen-ts로 TypeScript 클라이언트 코드를 생성한다. 디바운싱은 lodash.debounce를 사용한다. 500ms 디바운싱을 moveNode에 적용한다. 쓰로틀링은 lodash.throttle을 사용한다. 100ms 쓰로틀링을 커서 이벤트에 적용한다.

의존성: Milestone 2의 CRUD + 제스처 기능이 완료되어 있어야 한다. Zustand 스토어, Canvas 컴포넌트, FAB 버튼, 제스처 처리가 이미 구현되어 있다. Zustand 액션(createNode, moveNode 등)을 리팩토링하여 gRPC 호출을 추가한다. 기존 로컬 상태 업데이트는 Optimistic UI로 유지하고, 서버 응답을 기다린다. Docker Compose가 설정되어 있어야 한다. PostgreSQL 15, Envoy 프록시를 docker-compose.yml에 정의한다.

완료 조건: 브라우저 접속 시 localStorage에 세션 ID가 생성되고, 임시 닉네임 설정 모달이 표시된다. 닉네임을 설정하거나 스킵하면 워크스페이스가 로드된다. 최신 스냅샷 + 이후 이벤트가 재생되어 현재 상태가 복원된다. 노드를 생성하면 즉시 로컬 상태에 추가되고(Optimistic UI), 동시에 gRPC CreateNode RPC가 호출된다. 서버 응답이 성공하면 sequence_number를 받고 그대로 유지한다. 실패하면 로컬 상태를 롤백하고 토스트 알림을 표시한다. 노드를 드래그하면 즉시 로컬 상태가 업데이트되고, 드래그가 끝난 후 500ms 디바운싱 후 gRPC MoveNode RPC가 호출된다. 다른 사용자가 노드를 생성/이동/삭제하면 gRPC Server Streaming으로 WorkspaceUpdate 메시지를 수신한다. sequence_number 순서대로 Zustand 스토어에 적용되어 캔버스에 즉시 반영된다. 다른 사용자의 커서가 반투명 원과 닉네임으로 표시된다. 5초간 움직임이 없으면 페이드아웃된다. PostgreSQL workspace_events 테이블에 모든 operation이 저장된다. 매일 자정 workspace_snapshots 테이블에 스냅샷이 생성되고 7일 이전 이벤트가 삭제된다.

성공 지표: 사용자 5명이 동시에 노드를 편집하는 테스트를 수행한다. 모든 사용자가 동일한 최종 상태를 본다. 동시 이동 시 충돌이 Last Write Wins로 해결되어 일관성을 유지한다. operation 전송 지연이 100ms 이내이고, Server Streaming 지연이 50ms 이내이다. 스냅샷 복원 시간이 3초 이내이다(7일치 이벤트 기준). "부드럽다", "즉시 반영된다", "커서가 유용하다"는 피드백이 80% 이상이다.
