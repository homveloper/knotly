기술 스택: NestJS 10을 백엔드 프레임워크로 사용한다. @nestjs/microservices 패키지를 설치하여 gRPC 서비스를 구현한다. @grpc/grpc-js와 @grpc/proto-loader를 설치하여 Protobuf 파일을 로딩한다. protoc 컴파일러를 사용하여 .proto 파일을 TypeScript 코드로 자동 생성한다. PostgreSQL 15를 데이터베이스로 사용하며 pg 라이브러리로 직접 SQL을 작성한다. Connection Pool은 max 100, idleTimeoutMillis 30000으로 설정한다. Envoy 프록시 1.28을 Docker Compose로 실행하여 gRPC-Web 요청을 gRPC로 변환한다. 프론트엔드는 @improbable-eng/grpc-web 패키지를 설치하여 브라우저에서 gRPC 통신을 가능하게 한다. protoc-gen-ts 플러그인으로 클라이언트 TypeScript 코드를 생성한다. lodash.debounce와 lodash.throttle을 설치하여 디바운싱과 쓰로틀링을 구현한다.

아키텍처 개요: 백엔드는 3계층 구조로 설계한다. Controller 계층은 gRPC 요청을 받아 DTO로 변환한다. Service 계층은 비즈니스 로직을 처리하고 sequence number를 부여한다. Repository 계층은 PostgreSQL에 SQL을 직접 실행한다. 프론트엔드는 Zustand 스토어를 중심으로 설계한다. useCanvasStore는 nodes와 edges 배열을 관리하고, createNode, moveNode 등의 액션을 제공한다. 각 액션은 즉시 로컬 상태를 업데이트(Optimistic UI)하고, 동시에 gRPC Unary RPC를 호출한다. 서버 응답이 실패하면 롤백하고 토스트를 표시한다. useWorkspaceStream 훅은 gRPC Server Streaming 연결을 관리하고, WorkspaceUpdate 메시지를 수신하여 Zustand 스토어에 적용한다. useCursorTracking 훅은 마우스/터치 위치를 100ms 쓰로틀링하여 CursorMoved 메시지를 전송한다.

Protobuf 스키마 정의. proto/knotly.proto 파일을 생성한다. syntax = "proto3"을 선언한다. message Node를 정의하여 id, x, y, content, type, style, created_at, updated_at 필드를 추가한다. style 필드는 nested message Style {string background_color = 1; string stroke_color = 2; int32 stroke_width = 3;}로 정의한다. message Edge를 정의하여 id, from_id, to_id, line_style, created_at 필드를 추가한다. message WorkspaceUpdate를 정의하여 sequence_number, timestamp, session_id 필드와 oneof operation을 추가한다. oneof에는 NodeCreated, NodeMoved, NodeUpdated, NodeDeleted, EdgeCreated, EdgeDeleted 타입을 정의한다. message NodeCreated {Node node = 1;}처럼 각 operation 타입을 정의한다. service WorkspaceService를 정의하여 rpc CreateNode, rpc MoveNode, rpc UpdateNode, rpc DeleteNode, rpc CreateEdge, rpc DeleteEdge, rpc StreamWorkspaceUpdates를 추가한다. CreateNodeRequest는 {string workspace_id = 1; double x = 2; double y = 3; string content = 4;}로 정의한다. CreateNodeResponse는 {string node_id = 1; int64 sequence_number = 2;}로 정의한다. StreamRequest는 {string workspace_id = 1; string session_id = 2; int64 from_sequence_number = 3;}로 정의한다. from_sequence_number는 클라이언트가 이미 받은 마지막 sequence를 전달하여 재연결 시 누락된 이벤트만 받을 수 있도록 한다.

Protobuf 파일 컴파일. protoc 컴파일러를 설치한다. npm install -g protoc-gen-ts를 실행한다. proto 폴더에서 protoc --plugin=protoc-gen-ts=./node_modules/.bin/protoc-gen-ts --ts_out=src/generated --grpc_out=src/generated --plugin=protoc-gen-grpc=`which grpc_tools_node_protoc_plugin` knotly.proto를 실행한다. src/generated 폴더에 knotly_pb.ts와 knotly_grpc_pb.ts 파일이 생성되는지 확인한다. 이 파일들은 TypeScript 타입 정의와 gRPC 클라이언트/서버 스텁을 포함한다. package.json의 scripts에 "proto:build": "protoc --plugin=..."를 추가하여 자동화한다.

NestJS 프로젝트 초기화. nest new knotly-backend --package-manager pnpm을 실행한다. 프로젝트 폴더로 이동하여 pnpm add @nestjs/microservices @grpc/grpc-js @grpc/proto-loader pg uuid를 실행한다. pnpm add -D @types/pg @types/uuid를 실행한다. src/main.ts를 수정하여 HTTP 서버와 gRPC 마이크로서비스를 동시에 실행하도록 설정한다. const app = await NestFactory.create(AppModule)을 생성한 후 app.connectMicroservice를 호출하여 gRPC 설정을 추가한다. transport: Transport.GRPC, options: {package: 'knotly', protoPath: join(__dirname, '../proto/knotly.proto'), url: '0.0.0.0:50051'}을 설정한다. await app.startAllMicroservices()를 호출하여 gRPC 서버를 시작한다. await app.listen(3000)으로 HTTP 서버도 시작한다. 이는 헬스체크 엔드포인트를 제공하기 위함이다.

PostgreSQL 연결 설정. src/database/database.service.ts 파일을 생성한다. import { Pool } from 'pg'를 추가한다. @Injectable() 데코레이터를 사용하여 DatabaseService 클래스를 정의한다. private pool: Pool을 프로퍼티로 선언한다. constructor에서 this.pool = new Pool({host: process.env.DB_HOST || 'localhost', port: Number(process.env.DB_PORT) || 5432, database: process.env.DB_NAME || 'knotly', user: process.env.DB_USER || 'postgres', password: process.env.DB_PASSWORD, max: 100, idleTimeoutMillis: 30000})을 초기화한다. async query<T>(text: string, params?: any[]): Promise<T[]> 메서드를 추가하여 const result = await this.pool.query(text, params); return result.rows;를 반환한다. async transaction<T>(callback: (client: PoolClient) => Promise<T>): Promise<T> 메서드를 추가하여 const client = await this.pool.connect(); try { await client.query('BEGIN'); const result = await callback(client); await client.query('COMMIT'); return result; } catch (e) { await client.query('ROLLBACK'); throw e; } finally { client.release(); }를 구현한다. 이는 Constitution 원칙 I에 따른 에러 핸들링이다. onModuleDestroy 라이프사이클 훅에서 await this.pool.end()를 호출하여 연결을 정리한다.

데이터베이스 스키마 생성. migrations/001_create_workspace_events.sql 파일을 작성한다. CREATE TABLE IF NOT EXISTS workspace_events (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), workspace_id UUID NOT NULL, sequence_number BIGSERIAL NOT NULL, operation_type VARCHAR(50) NOT NULL, operation_data JSONB NOT NULL, session_id UUID NOT NULL, timestamp BIGINT NOT NULL, created_at TIMESTAMP DEFAULT NOW(), UNIQUE(workspace_id, sequence_number))를 실행한다. CREATE INDEX idx_workspace_events_workspace_id ON workspace_events(workspace_id)를 추가한다. CREATE INDEX idx_workspace_events_sequence ON workspace_events(workspace_id, sequence_number)를 추가하여 sequence 순서대로 조회를 빠르게 한다. migrations/002_create_workspace_snapshots.sql 파일을 작성한다. CREATE TABLE IF NOT EXISTS workspace_snapshots (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), workspace_id UUID NOT NULL, snapshot_data JSONB NOT NULL, snapshot_at TIMESTAMP DEFAULT NOW(), event_sequence_number BIGINT NOT NULL, UNIQUE(workspace_id, snapshot_at))를 실행한다. CREATE INDEX idx_workspace_snapshots_workspace_id ON workspace_snapshots(workspace_id)를 추가한다. pnpm add -D node-pg-migrate를 설치하여 마이그레이션 도구를 사용한다. package.json의 scripts에 "migrate:up": "node-pg-migrate up"을 추가한다.

WorkspaceService 구현. src/workspace/workspace.service.ts 파일을 생성한다. @Injectable() 데코레이터를 사용한다. constructor(private readonly db: DatabaseService)를 주입한다. async createNode(workspaceId: string, sessionId: string, x: number, y: number, content: string) 메서드를 구현한다. const nodeId = uuid()를 생성한다. const timestamp = Date.now()를 생성한다. this.db.transaction을 호출하여 트랜잭션 내에서 실행한다. INSERT INTO workspace_events (workspace_id, operation_type, operation_data, session_id, timestamp) VALUES ($1, 'NodeCreated', $2, $3, $4) RETURNING sequence_number를 실행한다. operation_data는 JSON.stringify({id: nodeId, x, y, content, type: 'circle', style: {...}, createdAt: timestamp, updatedAt: timestamp})로 설정한다. sequence_number를 반환받아 {nodeId, sequenceNumber}를 리턴한다. async moveNode(nodeId: string, workspaceId: string, sessionId: string, x: number, y: number) 메서드를 구현한다. 먼저 SELECT operation_data FROM workspace_events WHERE workspace_id = $1 AND operation_type = 'NodeDeleted' AND operation_data->>'id' = $2 ORDER BY sequence_number DESC LIMIT 1을 실행하여 노드가 삭제되었는지 확인한다. 삭제되었으면 {success: false, error: 'Node has been deleted'}를 반환한다. 삭제되지 않았으면 트랜잭션 내에서 INSERT INTO workspace_events (workspace_id, operation_type, operation_data, session_id, timestamp) VALUES ($1, 'NodeMoved', $2, $3, $4) RETURNING sequence_number를 실행한다. operation_data는 JSON.stringify({id: nodeId, x, y, timestamp: Date.now()})로 설정한다. {success: true, sequenceNumber}를 반환한다. async deleteNode(nodeId: string, workspaceId: string, sessionId: string) 메서드를 구현한다. 트랜잭션 내에서 NodeDeleted 이벤트를 삽입하고, 연결된 엣지도 자동으로 삭제하기 위해 SELECT id FROM edges WHERE from_id = $1 OR to_id = $1를 조회한 후 각 엣지에 대해 EdgeDeleted 이벤트를 삽입한다.

WorkspaceController 구현. src/workspace/workspace.controller.ts 파일을 생성한다. @Controller() 데코레이터를 사용하고 @GrpcMethod('WorkspaceService', 'CreateNode') 데코레이터를 추가한다. async createNode(data: CreateNodeRequest, metadata: Metadata): Promise<CreateNodeResponse> 메서드를 구현한다. metadata에서 session-id를 추출한다. const sessionId = metadata.get('session-id')[0]를 실행한다. sessionId가 없으면 throw new RpcException({code: status.INVALID_ARGUMENT, message: 'session-id is required'})를 던진다. 이는 Constitution 원칙에 어긋나지만 gRPC 프레임워크에서 권장하는 방식이므로 예외적으로 허용한다. this.workspaceService.createNode(data.workspace_id, sessionId, data.x, data.y, data.content)를 호출하여 결과를 받는다. {node_id: result.nodeId, sequence_number: result.sequenceNumber}를 반환한다. @GrpcMethod('WorkspaceService', 'MoveNode') async moveNode(data: MoveNodeRequest, metadata: Metadata): Promise<MoveNodeResponse> 메서드를 구현한다. 마찬가지로 session-id를 추출하고 this.workspaceService.moveNode를 호출한다. 실패 시 {success: false, error: result.error}를 반환한다.

Server Streaming RPC 구현. WorkspaceService에 private activeStreams = new Map<string, Subject<WorkspaceUpdate>>()를 추가한다. async getOrCreateStream(workspaceId: string): Promise<Subject<WorkspaceUpdate>> 메서드를 구현한다. if (!this.activeStreams.has(workspaceId))를 체크하고, 없으면 new Subject<WorkspaceUpdate>()를 생성하여 Map에 저장한다. 있으면 기존 Subject를 반환한다. createNode, moveNode 등의 메서드에서 이벤트를 삽입한 후 const stream = await this.getOrCreateStream(workspaceId)를 호출하고 stream.next({sequence_number: sequenceNumber, timestamp, session_id: sessionId, operation: {node_created: {...}}})를 emit한다. WorkspaceController에 @GrpcStreamMethod('WorkspaceService', 'StreamWorkspaceUpdates') streamWorkspaceUpdates(data: Observable<StreamRequest>): Observable<WorkspaceUpdate> 메서드를 구현한다. data.pipe(switchMap(async (request) => {...}))로 처리한다. 먼저 from_sequence_number가 제공되면 SELECT * FROM workspace_events WHERE workspace_id = $1 AND sequence_number > $2 ORDER BY sequence_number ASC를 조회하여 누락된 이벤트를 먼저 전송한다. 그 후 this.workspaceService.getOrCreateStream(request.workspace_id)를 호출하여 Subject를 구독한다. 구독한 이벤트를 클라이언트로 스트리밍한다.

스냅샷 생성 스케줄러 구현. pnpm add @nestjs/schedule를 설치한다. AppModule의 imports에 ScheduleModule.forRoot()를 추가한다. src/snapshot/snapshot.service.ts 파일을 생성한다. @Injectable() 데코레이터를 사용한다. constructor(private readonly db: DatabaseService)를 주입한다. @Cron('0 0 * * *') async createDailySnapshots() 메서드를 추가하여 매일 자정에 실행되도록 한다. SELECT DISTINCT workspace_id FROM workspace_events를 조회하여 모든 워크스페이스 ID를 가져온다. 각 워크스페이스에 대해 스냅샷을 생성한다. SELECT operation_data FROM workspace_events WHERE workspace_id = $1 ORDER BY sequence_number ASC를 조회하여 모든 이벤트를 재생한다. 재생 로직은 in-memory로 nodes와 edges 배열을 구성한다. operation_type이 'NodeCreated'이면 nodes.push(operation_data)를 실행한다. 'NodeMoved'이면 const node = nodes.find(n => n.id === operation_data.id)를 찾아 node.x = operation_data.x; node.y = operation_data.y; node.updatedAt = operation_data.timestamp를 업데이트한다. 'NodeDeleted'이면 nodes = nodes.filter(n => n.id !== operation_data.id)를 실행한다. 마찬가지로 EdgeCreated, EdgeDeleted도 처리한다. 최종 상태를 snapshot_data JSONB로 저장한다. INSERT INTO workspace_snapshots (workspace_id, snapshot_data, event_sequence_number) VALUES ($1, $2, $3)를 실행한다. event_sequence_number는 마지막 이벤트의 sequence_number를 저장한다. DELETE FROM workspace_events WHERE workspace_id = $1 AND created_at < NOW() - INTERVAL '7 days'를 실행하여 7일 이전 이벤트를 삭제한다.

Envoy 프록시 설정. docker-compose.yml 파일을 생성한다. services: postgres: image: postgres:15, environment: POSTGRES_DB=knotly, POSTGRES_USER=postgres, POSTGRES_PASSWORD=password, ports: 5432:5432, volumes: ./data/postgres:/var/lib/postgresql/data를 정의한다. envoy: image: envoyproxy/envoy:v1.28.0, ports: 8080:8080, 9901:9901, volumes: ./envoy.yaml:/etc/envoy/envoy.yaml을 정의한다. backend: build: ., ports: 50051:50051, 3000:3000, depends_on: postgres, envoy, environment: DB_HOST=postgres를 정의한다. envoy.yaml 파일을 생성한다. static_resources: listeners: name: listener_0, address: {socket_address: {address: 0.0.0.0, port_value: 8080}}, filter_chains: filters: name: envoy.filters.network.http_connection_manager, typed_config: @type: type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager, codec_type: AUTO, stat_prefix: ingress_http, route_config: {name: local_route, virtual_hosts: [{name: backend, domains: ["*"], routes: [{match: {prefix: "/"}, route: {cluster: grpc_backend}}], cors: {allow_origin_string_match: [{safe_regex: {regex: ".*"}}], allow_methods: "GET, POST, OPTIONS", allow_headers: "content-type, x-grpc-web, x-user-agent, session-id", expose_headers: "grpc-status, grpc-message"}]}, http_filters: [{name: envoy.filters.http.grpc_web}, {name: envoy.filters.http.cors}, {name: envoy.filters.http.router}]를 설정한다. clusters: name: grpc_backend, connect_timeout: 5s, type: LOGICAL_DNS, lb_policy: ROUND_ROBIN, dns_lookup_family: V4_ONLY, typed_extension_protocol_options: {envoy.extensions.upstreams.http.v3.HttpProtocolOptions: {explicit_http_config: {http2_protocol_options: {}}}}, load_assignment: {cluster_name: grpc_backend, endpoints: [{lb_endpoints: [{endpoint: {address: {socket_address: {address: backend, port_value: 50051}}}}]}]}를 설정한다.

프론트엔드 gRPC-Web 클라이언트 설정. knotly-frontend 폴더로 이동한다. pnpm add @improbable-eng/grpc-web google-protobuf를 설치한다. pnpm add -D @types/google-protobuf를 설치한다. protoc 컴파일러를 사용하여 클라이언트 코드를 생성한다. protoc --plugin=protoc-gen-ts=./node_modules/.bin/protoc-gen-ts --ts_out=service=grpc-web:src/generated --proto_path=../knotly-backend/proto ../knotly-backend/proto/knotly.proto를 실행한다. src/generated 폴더에 knotly_pb.ts와 KnotlyServiceClientPb.ts 파일이 생성된다. src/services/grpcClient.ts 파일을 생성한다. import { WorkspaceServiceClient } from '../generated/KnotlyServiceClientPb'를 추가한다. export const grpcClient = new WorkspaceServiceClient('http://localhost:8080', null, null)를 초기화한다. 프로덕션 환경에서는 환경변수로 URL을 설정한다.

Zustand 스토어 gRPC 호출 리팩토링. src/store/canvasStore.ts를 수정한다. import { grpcClient } from '../services/grpcClient'를 추가한다. import { Metadata } from 'grpc-web'를 추가한다. import debounce from 'lodash.debounce'를 추가한다. pnpm add lodash.debounce @types/lodash.debounce를 설치한다. createNode 액션을 수정한다. 먼저 const newNode = {id: uuid(), position: {x, y}, content, type: 'circle', style: {...}, createdAt: Date.now(), updatedAt: Date.now()}를 생성한다. set((state) => ({nodes: [...state.nodes, newNode]}))로 Optimistic UI를 적용한다. 그 후 try { const metadata = new Metadata(); metadata.append('session-id', getSessionId()); const request = new CreateNodeRequest(); request.setWorkspaceId(workspaceId); request.setX(x); request.setY(y); request.setContent(content); const response = await grpcClient.createNode(request, metadata); console.log('Node created with sequence:', response.getSequenceNumber()); } catch (error) { set((state) => ({nodes: state.nodes.filter(n => n.id !== newNode.id)})); toast.error('노드 생성에 실패했습니다'); }를 추가한다. moveNode 액션을 디바운싱으로 감싼다. const debouncedMoveNode = debounce(async (nodeId, x, y) => { try { const metadata = new Metadata(); metadata.append('session-id', getSessionId()); const request = new MoveNodeRequest(); request.setNodeId(nodeId); request.setX(x); request.setY(y); const response = await grpcClient.moveNode(request, metadata); if (!response.getSuccess()) { toast.error(response.getError()); } } catch (error) { toast.error('노드 이동에 실패했습니다'); } }, 500)를 정의한다. moveNode 액션 내부에서 set((state) => ({nodes: state.nodes.map(n => n.id === nodeId ? {...n, position: {x, y}} : n)}))로 Optimistic UI를 먼저 적용하고, debouncedMoveNode(nodeId, x, y)를 호출한다.

Server Streaming 구독 및 실시간 업데이트. src/hooks/useWorkspaceStream.ts 파일을 생성한다. import { useEffect } from 'react'를 추가한다. import { grpcClient } from '../services/grpcClient'를 추가한다. import { useCanvasStore } from '../store/canvasStore'를 추가한다. export const useWorkspaceStream = (workspaceId: string) => 훅을 정의한다. useEffect(() => { const metadata = new Metadata(); metadata.append('session-id', getSessionId()); const request = new StreamRequest(); request.setWorkspaceId(workspaceId); request.setSessionId(getSessionId()); request.setFromSequenceNumber(0); const stream = grpcClient.streamWorkspaceUpdates(request, metadata); stream.on('data', (update: WorkspaceUpdate) => { if (update.getSessionId() === getSessionId()) return; if (update.hasNodeCreated()) { const nodeData = update.getNodeCreated().getNode(); useCanvasStore.getState().addRemoteNode(nodeData); } else if (update.hasNodeMoved()) { const moveData = update.getNodeMoved(); useCanvasStore.getState().moveRemoteNode(moveData.getId(), moveData.getX(), moveData.getY()); } else if (update.hasNodeDeleted()) { const deleteData = update.getNodeDeleted(); useCanvasStore.getState().deleteRemoteNode(deleteData.getId()); } }); stream.on('error', (error) => { console.error('Stream error:', error); toast.error('연결이 끊겼습니다. 재연결 중...'); setTimeout(() => { useWorkspaceStream(workspaceId); }, 3000); }); return () => stream.cancel(); }, [workspaceId])를 구현한다. Zustand 스토어에 addRemoteNode, moveRemoteNode, deleteRemoteNode 액션을 추가한다. 이 액션들은 gRPC 요청을 보내지 않고 로컬 상태만 업데이트한다.

세션 ID와 닉네임 관리. src/utils/session.ts 파일을 생성한다. export const getSessionId = (): string => { let sessionId = localStorage.getItem('knotly-session-id'); if (!sessionId) { sessionId = uuid(); localStorage.setItem('knotly-session-id', sessionId); } return sessionId; }를 구현한다. export const getNickname = (): string => { return localStorage.getItem('knotly-nickname') || `익명 사용자 ${Math.floor(Math.random() * 9000) + 1000}`; }를 구현한다. export const setNickname = (nickname: string): void => { localStorage.setItem('knotly-nickname', nickname); }를 구현한다. src/components/NicknameModal.tsx 파일을 생성한다. useState로 입력값을 관리하고, 제출 시 setNickname을 호출한다. 스킵 버튼을 제공하여 닉네임 없이도 진행할 수 있도록 한다. 모달은 처음 접속 시 1회만 표시되고, localStorage에 'knotly-nickname-set' 플래그를 저장하여 이미 설정했는지 확인한다.

커서 위치 공유 구현. src/hooks/useCursorTracking.ts 파일을 생성한다. pnpm add lodash.throttle @types/lodash.throttle을 설치한다. import throttle from 'lodash.throttle'를 추가한다. useEffect(() => { const handleMouseMove = throttle((e: MouseEvent) => { const metadata = new Metadata(); metadata.append('session-id', getSessionId()); const request = new CursorMovedRequest(); request.setSessionId(getSessionId()); request.setNickname(getNickname()); request.setX(e.clientX); request.setY(e.clientY); request.setTimestamp(Date.now()); grpcClient.sendCursorPosition(request, metadata).catch(console.error); }, 100); window.addEventListener('mousemove', handleMouseMove); return () => window.removeEventListener('mousemove', handleMouseMove); }, [])를 구현한다. src/components/RemoteCursors.tsx 파일을 생성한다. useState로 {[sessionId: string]: {x: number, y: number, nickname: string, color: string, lastUpdate: number}} 형태의 커서 맵을 관리한다. useEffect에서 gRPC Server Streaming으로 CursorMoved 메시지를 구독한다. 수신 시 setCursors((prev) => ({...prev, [sessionId]: {...}}))로 업데이트한다. setInterval을 사용하여 1초마다 Date.now() - lastUpdate > 5000인 커서를 삭제한다. 각 커서는 div style={{position: 'absolute', left: x, top: y, width: 20, height: 20, borderRadius: '50%', backgroundColor: color, opacity: 0.6}}로 렌더링한다. nickname은 div style={{position: 'absolute', left: x + 25, top: y, fontSize: 12, color: '#333'}}로 표시한다. 색상은 7가지 파스텔 톤 배열을 정의하고 sessionId를 해시하여 인덱스를 결정한다.

워크스페이스 스냅샷 및 이벤트 복원. src/hooks/useWorkspaceLoader.ts 파일을 생성한다. useEffect(() => { const loadWorkspace = async () => { const response = await fetch(`http://localhost:3000/workspaces/${workspaceId}/snapshot`); const {snapshot, events} = await response.json(); if (snapshot) { useCanvasStore.getState().loadSnapshot(snapshot.snapshot_data); } events.forEach((event) => { if (event.operation_type === 'NodeCreated') { useCanvasStore.getState().addRemoteNode(event.operation_data); } else if (event.operation_type === 'NodeMoved') { useCanvasStore.getState().moveRemoteNode(event.operation_data.id, event.operation_data.x, event.operation_data.y); } }); }; loadWorkspace(); }, [workspaceId])를 구현한다. 백엔드에 HTTP 엔드포인트를 추가한다. src/workspace/workspace.controller.ts에 @Get('/workspaces/:id/snapshot') async getWorkspaceSnapshot(@Param('id') workspaceId: string) 메서드를 추가한다. SELECT * FROM workspace_snapshots WHERE workspace_id = $1 ORDER BY snapshot_at DESC LIMIT 1을 조회하여 최신 스냅샷을 가져온다. 스냅샷이 있으면 SELECT * FROM workspace_events WHERE workspace_id = $1 AND sequence_number > $2 ORDER BY sequence_number ASC를 조회하여 스냅샷 이후 이벤트를 가져온다. {snapshot, events}를 반환한다. 스냅샷이 없으면 모든 이벤트를 반환한다.

에러 핸들링 및 재연결 로직. useWorkspaceStream 훅의 stream.on('error')에서 재연결 로직을 추가한다. 지수 백오프를 적용하여 재연결 시도 간격을 늘린다. let retryCount = 0; const maxRetries = 5; const retry = () => { if (retryCount >= maxRetries) { toast.error('서버에 연결할 수 없습니다'); return; } const delay = Math.min(1000 * Math.pow(2, retryCount), 10000); setTimeout(() => { retryCount++; useWorkspaceStream(workspaceId); }, delay); }를 구현한다. stream.on('end')에서도 retry()를 호출하여 서버가 스트림을 종료한 경우에도 재연결한다. Zustand 스토어에 connectionStatus: 'connected' | 'disconnected' | 'reconnecting' 상태를 추가하고, UI에 배너로 표시한다. {connectionStatus === 'reconnecting' && <div className="fixed top-0 left-0 right-0 bg-yellow-500 text-white text-center py-2">연결이 끊겼습니다. 재연결 중...</div>}를 렌더링한다.

성능 최적화. RemoteCursors 컴포넌트에서 useMemo를 사용하여 커서 배열을 메모이제이션한다. const cursorArray = useMemo(() => Object.entries(cursors).map(([sessionId, cursor]) => ({sessionId, ...cursor})), [cursors])를 정의한다. 커서 렌더링에 React.memo를 적용하여 불필요한 리렌더링을 방지한다. const CursorItem = React.memo(({x, y, nickname, color}: {x: number, y: number, nickname: string, color: string}) => {...})를 정의한다. Zustand 스토어의 노드 업데이트에서 불변성을 유지한다. moveRemoteNode: (id, x, y) => set((state) => ({nodes: state.nodes.map(n => n.id === id ? {...n, position: {x, y}, updatedAt: Date.now()} : n)}))처럼 새 배열을 생성한다. gRPC 메시지 크기를 줄이기 위해 불필요한 필드를 제거한다. CursorMoved 메시지에서 createdAt, updatedAt 같은 필드를 제거하고 timestamp만 사용한다. Chrome DevTools의 Performance 탭에서 프로파일링을 수행한다. Long Task가 발생하는지 확인하고, 발생하면 해당 로직을 Web Worker로 이동하거나 requestIdleCallback으로 지연시킨다. Constitution 원칙 VIII에 따라 60fps 유지를 검증한다.

기술적 제약사항: gRPC Server Streaming은 HTTP/2를 사용하므로 HTTPS가 필요하다. 로컬 개발에서는 HTTP로 테스트하지만 프로덕션에서는 TLS 인증서를 설정해야 한다. Envoy 프록시는 단일 인스턴스로 실행되므로 프로덕션에서는 로드 밸런서 뒤에 여러 인스턴스를 배치해야 한다. PostgreSQL의 BIGSERIAL은 최대 9223372036854775807까지 증가하므로 워크스페이스당 operation이 이 값을 초과하면 오버플로우가 발생한다. 실무에서는 파티셔닝을 고려해야 하지만 학습 목적으로는 무시한다. WebSocket 대신 gRPC Server Streaming을 사용하므로 브라우저 호환성을 확인해야 한다. 모든 모던 브라우저(Chrome, Firefox, Safari, Edge)는 지원하지만 IE11은 지원하지 않는다. lodash.debounce와 lodash.throttle은 React 18의 Concurrent Mode와 충돌할 수 있으므로 useCallback으로 래핑한다. const debouncedMove = useCallback(debounce(moveNode, 500), [])처럼 사용한다. Constitution 원칙에 따라 throw를 사용하지 않는다. gRPC 에러는 RpcException으로 던지는 것이 프레임워크 규칙이므로 예외적으로 허용한다. 클라이언트에서는 try-catch로 에러를 처리하고 토스트를 표시한다.

참고 자료: NestJS gRPC 공식 문서 https://docs.nestjs.com/microservices/grpc에서 @GrpcMethod와 @GrpcStreamMethod 사용법을 확인한다. gRPC-Web 공식 문서 https://github.com/grpc/grpc-web에서 브라우저 클라이언트 설정을 확인한다. Envoy 프록시 gRPC-Web 필터 문서 https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_web_filter에서 CORS 설정을 확인한다. Protobuf 언어 가이드 https://protobuf.dev/programming-guides/proto3/에서 oneof, message, service 문법을 확인한다. PostgreSQL JSONB 타입 문서 https://www.postgresql.org/docs/current/datatype-json.html에서 JSONB 연산자를 확인한다. operation_data->>'id'는 JSONB에서 텍스트 값을 추출하는 연산자이다. Matt Weidner의 "List CRDTs with Move" 논문 https://mattweidner.com/2022/10/21/basic-list-crdt.html에서 서버 주도 ordering의 아이디어를 참고한다. Zustand 공식 문서 https://zustand-demo.pmnd.rs/에서 액션 정의와 구독 패턴을 확인한다. lodash debounce 문서 https://lodash.com/docs/4.17.15#debounce에서 leading, trailing 옵션을 확인한다. 드래그 종료 시에만 요청을 보내려면 {leading: false, trailing: true}로 설정한다.
