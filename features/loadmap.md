# Knotly 개발 로드맵

**프로젝트**: 손글씨 노트 느낌의 평평한 그래프 구조 기반 노트 애플리케이션
**목표**: MVP를 빠르게 개발하여 실사용 가능한 상태로 진화
**방법론**: 사양 기반 개발 (Specification-Driven Development) - WHAT에 초점

---

## 📋 프로젝트 정의

### 프로젝트 정체성과 핵심 가치

**Knotly는 손글씨 노트 느낌의 평평한 그래프 구조 기반 노트 애플리케이션입니다.** 사용자는 모눈종이 배경 위에서 다양한 손그림 스타일의 도형(동그라미, 네모, 구름 등 12가지)을 자유롭게 배치하고, 키보드로 입력한 텍스트가 손글씨 폰트(나눔손글씨 펜, Caveat)로 렌더링됩니다. 노드들은 점선으로 연결되며, 모든 노드는 계층 없이 동등한 관계로 존재합니다.

**이 프로젝트의 핵심 차별점은 대학 노트 필기 스타일의 자유로운 사고 정리입니다.** 기존 마인드맵 도구들의 딱딱한 비즈니스 느낌과 달리, Knotly는 낙서장처럼 편안하고 개인적인 경험을 제공합니다. 손그림 도형(rough.js)과 손글씨 폰트를 통해 따뜻하고 친근한 UI를 구현하며, 모바일 퍼스트 설계로 한 손으로 쉽게 사용할 수 있습니다.

**학습 목적으로 CQRS 패턴과 실시간 협업 기능을 단계적으로 구현합니다.** 이직 포트폴리오를 염두에 두고, 프론트엔드와 백엔드 모두에서 모던 아키텍처 패턴을 적용하며, Matt Weidner의 논문에서 영감을 받은 서버 주도 operation ordering 방식과 이벤트 소싱 기반 히스토리 추적, 그리고 gRPC Server Streaming 기반 실시간 협업 시스템을 MVP(Milestone 3-4)에서 구현합니다. CRDT의 복잡한 수학 대신 서버가 operation 순서를 결정하는 단순한 방식을 채택하며, Protobuf로 타입 안전성을 확보하고, 순수 PostgreSQL로 데이터베이스 원리를 깊이 학습합니다.

### 타겟 사용자와 사용 패턴

**타겟 사용자는 생각을 빠르게 정리하고 시각화하려는 지식 노동자입니다.** 개발자, 학생, 기획자, 작가 등 복잡한 개념을 연결하며 사고하는 사람들이 주 사용자이며, 디지털 도구에 익숙하지만 기존 마인드맵 도구의 딱딱함에 불만을 느끼는 사람들을 대상으로 합니다.

**주요 사용 패턴은 모바일에서 시작하고 데스크톱에서 확장하는 크로스 디바이스 협업 워크플로우입니다.** 출퇴근 중이나 회의 중에 모바일로 즉석 메모를 남기고, 나중에 데스크톱에서 노드를 추가하며 사고를 정교화합니다. 실시간 동기화를 통해 여러 디바이스에서 동일한 워크스페이스를 동시에 편집하고, 팀원들과 협업하며 아이디어를 발전시킬 수 있습니다.

### MVP 핵심 범위

**MVP는 멀티 사용자가 실시간으로 협업하며 노드를 생성하고 연결하는 핵심 기능에 집중합니다.** 여러 개의 워크스페이스(화이트보드)가 존재하며, 모든 사용자가 모든 워크스페이스에 접근하고 편집할 수 있습니다. gRPC Server Streaming 기반 실시간 동기화, 커서 위치 공유, 서버 주도 operation ordering으로 충돌을 해결합니다. PostgreSQL에 500ms 디바운싱 후 자동 저장되며, 별도 저장 버튼 없이 모든 변경사항이 자동으로 보존됩니다. 계정 시스템(회원가입, 로그인)과 권한 관리(소유자, 편집자, 뷰어)는 Phase 2로 미룹니다.

**모바일 반응형 웹과 실시간 협업이 MVP의 핵심 전략입니다.** FAB 버튼으로 빠른 노드 생성, 핀치/팬 제스처로 자유로운 캔버스 탐색, 롱프레스 컨텍스트 메뉴로 직관적인 편집을 제공합니다. gRPC-Web을 통해 프론트엔드와 백엔드가 타입 안전하게 통신하고, Server Streaming으로 다른 사용자의 변경사항을 실시간으로 수신합니다. 사용자 구분은 브라우저 세션 ID 또는 임시 닉네임으로 처리하며, 별도 인증 없이 즉시 협업을 시작할 수 있습니다.

**검색 기능과 접근성이 MVP 완성의 마지막 마일스톤입니다.** Fuse.js 퍼지 매칭으로 오타가 있어도 원하는 노드를 찾고, 키보드 네비게이션과 스크린 리더 지원으로 모든 사용자가 접근 가능하도록 만듭니다. WCAG 2.1 AA 기준을 준수하여 색상 대비를 보장하고, VoiceOver/TalkBack 테스트를 필수로 수행합니다.

### 제외 기능 (MVP 범위 밖)

**MVP에서 제외되는 첫 번째 카테고리는 오프라인 모드와 PWA입니다.** Service Worker를 활용한 오프라인 에셋 캐싱, IndexedDB를 활용한 로컬 데이터 저장, manifest.json을 활용한 홈화면 설치, 오프라인 환경에서의 작업 및 네트워크 재연결 시 자동 동기화는 Phase 2로 미룹니다. MVP는 온라인 환경에서 실시간 협업에 집중하며, 안정적인 인터넷 연결을 전제로 합니다.

**고급 UX 기능과 시각적 확장은 Milestone 6 이후로 연기합니다.** 12가지 도형 중 MVP는 동그라미 1개만 우선 지원하고, 나머지 11개는 Milestone 6에서 추가합니다. 5가지 연결선 스타일 중 점선만 MVP에 포함하고, 실선/곡선/화살표는 추후 단계에서 구현합니다. Undo/Redo 기능은 Phase 2에서 이벤트 소싱을 활용하여 구현하고, 선의 곡률 조절, 노드 그룹화, 템플릿 저장도 Phase 2 이후입니다.

**AI 기능과 고급 그래프 분석은 Phase 3 장기 로드맵입니다.** AI 기반 자동 연결 제안, 요약 생성, 관련 노드 추천은 Phase 3에 배정됩니다. 노드 간 최단 경로 찾기, 클러스터 감지, 그래프 분석, 자동 레이아웃 제안 등도 추후 추가하며, 이미지/파일 첨부, PDF 임베딩, 리치 텍스트 편집(볼드, 이탤릭)도 Phase 3 이후로 미룹니다.

### 플랫폼 전략 및 디바이스별 UX

#### 모바일 퍼스트 전략

**Knotly는 모바일 환경을 1순위로 최적화합니다.** 한 손으로 쉽게 조작할 수 있도록 우하단 FAB 버튼 배치, 엄지손가락 도달 범위 내 주요 기능 배치, 터치 타겟 최소 44px 크기를 준수합니다. 핀치 제스처로 캔버스 줌인/줌아웃, 투 핑거 드래그로 캔버스 팬, 롱프레스로 컨텍스트 메뉴를 호출하는 직관적인 제스처를 제공합니다.

**모바일 UX의 핵심은 빠른 노드 생성과 자연스러운 텍스트 입력입니다.** FAB 버튼(+)을 탭하면 즉시 캔버스 중앙에 노드가 생성되고 소프트 키보드가 올라와 텍스트 입력 모드로 전환됩니다. 입력한 텍스트는 실시간으로 손글씨 폰트로 렌더링되어 손으로 쓰는 듯한 피드백을 제공합니다. 노드를 한 번 탭하면 편집 모드, 드래그하면 이동, 롱프레스하면 배경색 변경/삭제 메뉴가 나타나는 명확한 제스처 구분을 제공합니다.

**@멘션으로 빠른 연결을 지원합니다.** 텍스트 입력 중 @ 기호를 입력하면 기존 노드 목록이 바텀시트로 표시되고, 선택 시 자동으로 점선이 연결됩니다. 수동 연결이 필요한 경우 연결 모드 버튼(🔗)을 탭한 후 두 노드를 순차적으로 탭하여 연결합니다.

#### 태블릿 UX (Milestone 6)

**태블릿은 듀얼 뷰 레이아웃으로 생산성을 향상시킵니다.** 화면 왼쪽에는 도형 팔레트와 색상 선택기가 고정되어 있고, 중앙과 오른쪽은 넓은 캔버스 영역으로 활용됩니다. 도형을 드래그 앤 드롭으로 캔버스에 바로 배치할 수 있으며, 여러 노드를 동시에 선택(Shift+클릭 또는 라쏘 드래그)하여 일괄 이동, 색상 변경, 삭제가 가능합니다.

**가로 모드에서는 3단 레이아웃을 제공합니다.** 왼쪽 패널에 도형/색상 도구, 중앙에 메인 캔버스, 오른쪽 패널에 속성 편집기(선택한 노드의 스타일, 연결 정보, 메타데이터)를 배치합니다. 각 패널은 드래그로 크기 조절이 가능하며, 필요 없는 패널은 숨길 수 있습니다. Apple Pencil이나 S Pen을 사용하는 경우 더 정밀한 노드 배치와 선 연결이 가능합니다.

#### 데스크톱 UX (Milestone 6)

**데스크톱은 마우스와 키보드 중심의 프로 워크플로우를 제공합니다.** 좌측 사이드바에 도형 팔레트, 색상 선택기, 최근 작업 히스토리가 표시되고, 중앙의 넓은 캔버스에서 작업하며, 우측 사이드바에 속성 패널과 미니맵이 위치합니다. 마우스 호버 시 노드에 핸들이 나타나 연결선을 그릴 수 있고, 더블클릭으로 텍스트 편집 모드에 진입합니다.

**키보드 단축키는 빠른 작업 흐름을 지원합니다.** N 또는 더블클릭으로 새 노드 생성, Delete/Backspace로 삭제, Ctrl+C/V로 복사/붙여넣기, Ctrl+Z로 Undo(Phase 2에서 완전 구현), / 또는 Ctrl+F로 검색, Ctrl+D로 선택한 노드 복제, Ctrl+A로 전체 선택, Ctrl+L로 연결 모드 진입, Esc로 선택 해제 등을 지원합니다. Ctrl+마우스휠로 빠른 줌, Ctrl+0으로 전체 보기, Ctrl+1로 100% 확대 등의 뷰 조작 단축키도 제공합니다.

**고급 편집 기능과 배치 도구를 제공합니다.** 여러 노드를 선택하여 정렬(좌우 정렬, 상하 정렬, 균등 분포), 레이어 순서 조정(앞으로/뒤로 보내기)을 할 수 있습니다. 안내선(가이드라인)이 노드 이동 시 자동으로 나타나 다른 노드와 정렬을 돕고, 스마트 가이드가 등간격 배치를 제안합니다. 격자 스냅 강도를 조절할 수 있으며, Alt 키를 누르고 드래그하면 스냅을 일시적으로 비활성화합니다.

### 기술 스택 선정

#### 프론트엔드: React + gRPC-Web

**프론트엔드는 React 18 + TypeScript 기반의 반응형 웹앱으로 구현합니다.** 손그림 도형 렌더링을 위해 rough.js를 사용하고, 상태 관리는 Zustand로 경량화하며, 터치 제스처는 react-use-gesture로 처리합니다. 스타일링은 Tailwind CSS를 사용하고, 손글씨 폰트는 Google Fonts의 Caveat(영문)와 나눔손글씨 펜(한글)을 웹폰트로 로딩합니다. Canvas 렌더링과 SVG를 혼합하여 성능과 품질을 최적화합니다.

**백엔드와의 통신은 gRPC-Web을 사용합니다.** Protobuf 스키마로 정의된 메시지 타입을 TypeScript 코드로 자동 생성하여 타입 안전성을 확보합니다. HTTP/2를 활용한 바이너리 직렬화로 Socket.io 대비 약 50% 작은 payload를 전송하며, gRPC Server Streaming을 통해 실시간 업데이트를 수신합니다. Envoy 프록시가 브라우저의 HTTP/2 요청을 gRPC로 변환하여 백엔드와 통신합니다.

#### 백엔드: NestJS + gRPC + 순수 PostgreSQL

**백엔드는 NestJS + CQRS 패턴으로 구현하며 PostgreSQL을 데이터베이스로 사용합니다.** ORM 없이 순수 `pg` 라이브러리로 SQL을 직접 작성하여 데이터베이스 원리를 깊이 학습합니다. Connection Pool 관리, 트랜잭션 제어, 쿼리 최적화, 인덱스 설계를 직접 수행하며, SQL 마이그레이션 스크립트를 수동으로 작성하여 스키마 변경을 명확히 관리합니다.

**실시간 협업은 gRPC Server Streaming + 서버 주도 operation ordering으로 구현합니다.** Protobuf 스키마에 Node, Edge, User, Workspace 메시지와 CreateNode, UpdateNode, StreamWorkspaceUpdates 등의 RPC를 정의합니다. Unary RPC로 CRUD 작업을 처리하고, Server Streaming RPC로 워크스페이스의 변경사항을 실시간으로 푸시합니다. 서버가 모든 operation에 sequence number를 부여하여 순서를 결정하며, 충돌 해결은 간단한 비즈니스 규칙으로 처리합니다 (예: 동시 이동 시 마지막 timestamp 우선, 삭제된 노드 수정은 무시). 이벤트 소싱으로 히스토리를 추적하되, 영속성 레이어 폭발을 방지하기 위해 매일 자정 스냅샷을 생성하고 7일 이전 이벤트는 자동 삭제합니다. 워크스페이스 로드 시 최신 스냅샷 + 이후 이벤트만 재생하여 빠른 복원을 보장합니다.

#### 학습 목표와 기술 선택 이유

**gRPC + Protobuf를 선택한 이유는 타입 안전성과 성능, 그리고 마이크로서비스 아키텍처 학습입니다.** Protobuf 스키마가 프론트-백엔드 간 계약 역할을 하며, 자동 코드 생성으로 타입 불일치를 컴파일 타임에 방지합니다. HTTP/2 기반 바이너리 통신으로 WebSocket 대비 낮은 오버헤드를 달성하고, 언어 중립적인 설계로 추후 Go/Rust 백엔드 추가 시에도 동일한 .proto 파일을 재사용할 수 있습니다.

**순수 PostgreSQL을 선택한 이유는 데이터베이스 원리와 SQL 최적화 학습입니다.** Prisma ORM의 추상화를 제거하고 SQL을 직접 작성하여 쿼리 실행 계획, 인덱스 활용, JOIN 최적화, 트랜잭션 격리 수준 등을 깊이 이해합니다. Connection Pool 크기 조정, Prepared Statement 활용, N+1 쿼리 방지 등 실전 성능 튜닝 기법을 습득합니다.

#### 배포 및 인프라

**프론트엔드는 Vercel에 배포하고, 백엔드는 Railway 또는 Fly.io에 배포합니다.** PostgreSQL은 Neon 또는 Supabase의 클라우드 인스턴스를 사용하며, GitHub Actions를 통한 CI/CD 파이프라인을 구축합니다. 로컬 개발 시 Docker Compose로 PostgreSQL 15, Envoy 프록시, Redis(선택사항)를 실행합니다.

#### 실시간 협업 아키텍처 상세

**서버 주도 operation ordering 방식으로 실시간 협업을 구현합니다.** CRDT나 OT의 복잡한 수학적 병합 알고리즘 대신, 서버가 모든 operation의 순서를 결정하는 단순한 방식을 채택합니다. 클라이언트가 operation(노드 이동, 수정, 삭제 등)을 전송하면, 서버는 sequence number를 부여하고 PostgreSQL events 테이블에 기록한 후 다른 모든 클라이언트에게 gRPC Server Streaming으로 broadcast합니다. 이 방식은 Matt Weidner의 "Text Without CRDTs" 논문에서 영감을 받았으며, CRDT보다 구현이 단순하면서도 실시간 협업에 충분합니다.

**충돌 해결 규칙은 서버의 단순한 비즈니스 로직으로 구현됩니다.** 동일 노드를 두 사용자가 동시에 이동하면 마지막 timestamp가 우선하고(Last Write Wins), 삭제된 노드를 다른 사용자가 수정하려 하면 무시하며(삭제 우선), 존재하지 않는 노드에 엣지를 생성하려 하면 자동으로 실패합니다. 이러한 규칙은 CRDT의 교환법칙/결합법칙보다 훨씬 이해하기 쉽고 비즈니스 요구사항에 맞게 유연하게 조정할 수 있습니다.

**클라이언트는 Optimistic UI + Server Reconciliation 패턴을 사용합니다.** 사용자가 노드를 드래그하면 즉시 Zustand 로컬 상태를 업데이트하여 부드러운 UX를 제공하고, 동시에 gRPC Unary RPC로 서버에 operation을 전송합니다. 서버로부터 다른 사용자의 operation이 도착하면 서버가 결정한 sequence number 순서대로 로컬 상태에 적용합니다. 내 operation이 서버에서 거부되면(권한 없음, 삭제된 노드 등) 로컬 상태를 롤백하고 사용자에게 알립니다. 500ms 디바운싱을 적용하여 드래그 중에는 요청을 보내지 않고, 드래그가 끝난 후 최종 위치만 전송하여 네트워크 트래픽을 최소화합니다.

**이벤트 소싱과 스냅샷 하이브리드 전략으로 영속성을 관리합니다.** 모든 operation을 PostgreSQL workspace_events 테이블에 sequence number와 함께 기록하여 완벽한 히스토리 추적을 제공합니다. 그러나 이벤트를 무한정 쌓으면 DB가 폭발하고 로딩 시간이 느려지므로, 매일 자정 전체 워크스페이스 상태의 스냅샷을 workspace_snapshots 테이블에 생성하고 7일 이전 이벤트는 자동 삭제합니다. 워크스페이스 로드 시 최신 스냅샷 + 이후 이벤트들만 재생하여 현재 상태를 복원하므로, 1년치 히스토리가 있어도 최대 7일치 이벤트만 처리하면 됩니다. 스냅샷은 30일간 보관하여 Time Travel 기능(Phase 2)에 활용합니다.

### 데이터 모델

**Node 엔티티는 모든 노드를 표현하는 핵심 데이터 구조입니다.** id(UUID), content(텍스트 내용), type(도형 종류: circle, rect, cloud 등 12가지), x와 y(캔버스 좌표), style(배경색, 테두리색, 굵기 등 스타일 정보), emoji(선택적 이모지), createdAt과 updatedAt 타임스탬프를 포함합니다. 모든 노드는 평등하며 부모-자식 관계가 없습니다.

**Edge 엔티티는 노드 간의 연결을 표현합니다.** id(UUID), fromId(출발 노드), toId(도착 노드), lineStyle(점선, 실선, 화살표 등 5가지), createdAt을 포함합니다. fromId와 toId의 조합은 유니크하며, 양방향 링크를 지원하기 위해 역방향 엣지도 명시적으로 생성할 수 있습니다. 삭제 시 Cascade 옵션으로 노드 삭제 시 연결된 엣지도 자동 삭제됩니다.

**Workspace 엔티티는 여러 노드와 엣지를 그룹화하는 컨테이너 역할을 합니다.** id(UUID), name, description, createdAt, updatedAt을 포함합니다. Node와 Edge는 workspaceId를 외래키로 가지며, Workspace 삭제 시 모든 노드와 엣지도 CASCADE 삭제됩니다. MVP에서는 모든 워크스페이스가 공개되어 있으며, 모든 사용자가 모든 워크스페이스에 접근하고 편집할 수 있습니다. 계정 시스템과 권한 관리는 Phase 2에서 추가합니다.

### 프로젝트 기반 구축

**로컬 개발 환경은 Docker Compose로 표준화합니다.** PostgreSQL 15, Envoy 프록시, Redis(선택사항)를 docker-compose.yml로 정의하고, 로컬 개발 시 한 번의 명령으로 전체 인프라를 구축합니다. 프론트엔드는 Vite 개발 서버를 실행하고, 백엔드는 NestJS 개발 모드로 실행하여 핫 리로딩을 지원합니다. Envoy 프록시는 8080 포트에서 gRPC-Web 요청을 받아 백엔드의 gRPC 서버(50051 포트)로 전달합니다.

**초기 프로젝트 셋업은 프론트엔드, 백엔드, Protobuf 스키마를 포함합니다.** 프론트엔드는 React + Vite + TypeScript 프로젝트를 생성하고, gRPC-Web 클라이언트 라이브러리를 설치합니다. 백엔드는 NestJS + gRPC 프로젝트를 초기화하고, pg 라이브러리로 PostgreSQL에 연결합니다. Protobuf 스키마(knotly.proto)를 정의하여 Node, Edge, User, Workspace 메시지와 RPC를 선언하고, protoc 컴파일러로 TypeScript 코드를 자동 생성합니다. SQL 마이그레이션 스크립트를 작성하여 테이블 스키마를 관리합니다.

---

## 🚀 Milestone 1: 최소 동작 프로토타입 (Week 1-2)

### 목표
캔버스에 손그림 도형 1개를 렌더링하고 손글씨 텍스트 표시

### 기본 손그림 도형 (1개만)

**손그림 도형은 rough.js 라이브러리로 구현하여 자연스러운 손맛을 표현합니다.** roughness 파라미터를 1.2로 설정하여 약간의 거칠기를 부여하고, 선이 완벽하게 직선이나 원이 아닌 손으로 그린 듯한 미세한 떨림을 표현합니다. 이 단계에서는 **동그라미(circle) 1개**만 구현하며, strokeWidth는 2px, fillStyle은 solid, 기본 배경색은 노란색(#FFE082)으로 설정합니다.

### 손글씨 폰트 (한글 1개만)

**손글씨 폰트는 한글 기본 폰트만 우선 구현합니다.** 한글은 나눔손글씨 펜을 기본 폰트로 사용하며, 자연스럽고 가독성이 높은 손글씨 스타일을 제공합니다. 웹폰트는 preconnect와 display=swap을 활용하여 폰트 로딩 지연을 최소화하고, FOUT(Flash of Unstyled Text)를 방지합니다.

**텍스트 렌더링은 SVG text 요소로 구현하여 확대/축소 시에도 선명합니다.** 폰트 크기는 기본 18px, 줄간격은 1.5로 설정하여 읽기 편안한 밀도를 유지하고, 텍스트 색상은 진한 회색(#333)으로 통일하여 배경색과 무관하게 가독성을 보장합니다. 텍스트가 노드 영역을 벗어나면 자동으로 줄바꿈되며, 노드 크기는 텍스트 길이에 따라 동적으로 조절됩니다.

**프로토타입 완성 후에는 브라우저에서 손그림 도형과 손글씨 폰트를 확인할 수 있습니다.** 이 단계는 UI/UX의 방향성을 검증하는 중요한 마일스톤입니다.

---

## 📱 Milestone 2: 기본 CRUD, 모바일 제스처, 연결선 (Week 3-6)

### 목표
노드 생성/편집/이동/삭제 + 그리드 배경 + 모바일 터치 제스처 + 점선 연결 + @멘션

### 노드 CRUD 핵심 기능

**MVP 핵심 기능은 노드 생성, 편집, 삭제와 기본 이동 기능입니다.** 사용자는 동그라미 도형을 선택하여 노드를 생성하고, 키보드로 텍스트를 입력하며, 손글씨 폰트로 실시간 렌더링됩니다. 노드는 드래그로 자유롭게 이동할 수 있고, 롱프레스 또는 컨텍스트 메뉴로 삭제할 수 있습니다. 이 단계에서는 **@멘션 기능은 제외**하고 순수 노드 조작에 집중합니다.

### 그리드 배경과 기본 스타일링

**그리드 배경은 모눈종이 스타일로 구현하며 토글 가능합니다.** 20px 간격의 연한 회색(#e5e5e5) 선으로 수평/수직 격자를 그리고, 배경색은 거의 흰색에 가까운 #fafafa를 사용합니다. 사용자는 설정에서 그리드 ON/OFF, 스냅 기능 활성화 여부를 선택할 수 있습니다. 간격 조절과 다크모드는 추후 단계에서 구현합니다.

**색상 팔레트는 초기에 3가지 색상만 제공합니다.** 노란색(#FFE082, 포스트잇 기본), 하늘색(#90CAF9), 민트(#A5D6A7)를 지원하며, 각 색상은 손글씨 텍스트(#333)와 높은 대비를 유지하여 가독성을 보장합니다. 나머지 5가지 색상은 Milestone 6에서 추가합니다.

### 모바일 기본 UX

**노드 생성은 FAB 버튼으로 시작됩니다.** 화면 우하단의 플로팅 액션 버튼(+)을 탭하면 캔버스 중앙에 노드가 생성되며, 즉시 소프트 키보드가 올라오고 텍스트 입력 모드로 전환됩니다. 입력한 텍스트는 실시간으로 손글씨 폰트로 렌더링됩니다. 도형 선택 바텀시트는 Milestone 6에서 구현합니다.

**노드 편집과 이동은 직관적인 터치 제스처로 수행됩니다.** 노드를 한 번 탭하면 텍스트 편집 모드로 진입하여 기존 내용을 수정할 수 있고, 드래그하면 노드를 자유롭게 이동할 수 있습니다. 롱프레스하면 간단한 컨텍스트 메뉴가 나타나 배경색 변경(3가지 중 선택), 삭제 옵션을 선택할 수 있습니다. 핀치 제스처로 캔버스를 줌인/줌아웃할 수 있고, 투 핑거 드래그로 캔버스를 팬(이동)할 수 있습니다.

### 연결선 시스템

**연결선은 기본적으로 점선 스타일이며 초기에는 1가지만 지원합니다.** 점선만 구현하고, 실선/곡선/화살표는 Milestone 6에서 추가합니다. 모든 선은 rough.js로 렌더링하여 손그림 느낌을 유지하고, strokeWidth는 2px, 색상은 회색을 기본값으로 사용합니다. 선택된 선은 파란색으로 하이라이트되어 명확히 구분됩니다.

**선 연결은 수동 연결 방식으로 시작합니다.** 연결 모드 버튼을 탭한 후 시작 노드와 끝 노드를 순차적으로 탭하여 생성합니다. 선의 곡률 조절은 Phase 2로 미루고, 기본적으로는 두 노드를 직선으로 연결합니다. 선을 탭하면 선택 상태가 되고, 롱프레스하면 삭제됩니다. 노드 삭제 시 연결된 모든 선도 자동으로 삭제됩니다.

**@멘션 자동 연결로 빠른 연결을 지원합니다.** 텍스트 입력 중 @ 기호를 입력하면 기존 노드 목록이 바텀시트로 표시되고, 노드를 선택하면 현재 노드에서 선택한 노드로 점선이 자동 생성됩니다.

**Milestone 2 완료 후에는 노드 생성, 편집, 연결이 모두 가능한 기본 그래프 편집 환경이 구축됩니다.** 사용자는 모바일에서 FAB 버튼으로 노드를 추가하고, 드래그로 배치하며, 점선으로 연결하여 간단한 마인드맵을 작성할 수 있습니다.

---

## 🔄 Milestone 3: 실시간 협업 (Week 7-10)

### 목표
서버 주도 operation ordering + gRPC Server Streaming 기반 실시간 동기화 + 커서 위치 공유

**서버 주도 operation ordering 방식으로 실시간 동기화를 구현합니다.** 클라이언트가 StreamWorkspaceUpdates RPC를 호출하면, 백엔드는 해당 워크스페이스의 변경사항을 스트림으로 푸시합니다. 노드 생성, 수정, 삭제, 이동 등 모든 operation을 Protobuf WorkspaceUpdate 메시지로 정의하고, oneof를 활용하여 타입을 구분합니다. 서버는 각 operation에 sequence number를 부여하여 순서를 보장하며, 클라이언트는 이 순서대로 Zustand 스토어를 업데이트하여 캔버스에 즉시 반영합니다.

**충돌 해결은 서버의 비즈니스 규칙으로 처리합니다.** 동일 노드를 두 사용자가 동시에 이동하면 마지막 timestamp를 가진 operation이 우선합니다(Last Write Wins). 삭제된 노드를 수정하려는 operation은 서버에서 자동으로 무시하고 클라이언트에게 실패 응답을 보냅니다. 존재하지 않는 노드에 엣지를 생성하려는 시도도 마찬가지로 실패 처리합니다. 이러한 규칙은 CRDT의 복잡한 수학적 병합보다 훨씬 단순하고 이해하기 쉬우며, 비즈니스 요구사항에 맞게 유연하게 조정할 수 있습니다. MVP에서는 모든 사용자가 모든 워크스페이스에 접근하고 편집할 수 있으므로 권한 체크는 수행하지 않습니다.

**Optimistic UI 업데이트로 사용자 경험을 개선합니다.** 사용자가 노드를 이동하면 즉시 로컬 상태를 업데이트하고, 동시에 gRPC Unary RPC로 서버에 요청을 전송합니다. 서버 응답이 실패하면(삭제된 노드, 존재하지 않는 노드 등) 로컬 상태를 롤백하고 사용자에게 알림을 표시합니다. 성공하면 그대로 유지합니다. 500ms 디바운싱을 적용하여 드래그 중에는 요청을 보내지 않고, 드래그가 끝난 후 최종 위치만 전송하여 네트워크 트래픽을 최소화합니다.

**이벤트 소싱으로 모든 operation을 기록합니다.** 서버는 승인된 모든 operation을 workspace_events 테이블에 sequence number, timestamp, session_id(브라우저 세션 ID 또는 임시 닉네임)와 함께 저장하여 완벽한 히스토리 추적을 제공합니다. 매일 자정 스냅샷을 생성하고 7일 이전 이벤트는 자동 삭제하여 DB 크기를 관리합니다. 이를 통해 Phase 2의 Time Travel 기능과 충돌 분석 기능을 구현할 수 있는 기반을 마련합니다.

**사용자 식별은 브라우저 세션 ID 또는 임시 닉네임으로 처리합니다.** 브라우저 접속 시 UUID를 생성하여 localStorage에 저장하고, 모든 gRPC 요청에 메타데이터로 포함합니다. 사용자는 선택적으로 임시 닉네임을 설정할 수 있으며, 설정하지 않으면 "익명 사용자 1234"와 같이 무작위 번호가 부여됩니다. 계정 시스템과 영구 프로필은 Phase 2에서 추가합니다.

**커서 위치 공유로 실시간 협업 느낌을 강화합니다.** 각 사용자의 마우스 또는 터치 위치를 다른 사용자에게 표시합니다. CursorMovedEvent를 100ms 쓰로틀링하여 전송하고, 수신된 커서는 반투명 원과 사용자 닉네임으로 렌더링합니다. 5초간 움직임이 없으면 커서를 페이드아웃시켜 화면을 깔끔하게 유지합니다.

---

## 🔍 Milestone 4: 검색 기능 및 접근성 (Week 11-12)

### 목표
노드 전문 검색 + 키보드 네비게이션 + MVP 완성

### 전문 검색 구현

**전문 검색은 노드 내용을 실시간으로 검색하며 퍼지 매칭을 지원합니다.** 상단 검색바(🔍)에 키워드를 입력하면 Fuse.js 라이브러리로 모든 노드의 content 필드를 검색하고, 오타가 있어도 유사한 결과를 찾아줍니다(threshold: 0.3). 검색 결과는 하이라이트되어 표시되고, 매치된 노드는 캔버스에서 반짝이는 애니메이션으로 강조됩니다. 검색 결과를 탭하면 해당 노드로 자동 스크롤되고 줌인됩니다.

**검색 히스토리를 제공하여 재검색을 간소화합니다.** 최근 검색어 5개를 로컬 스토리지에 저장하고, 검색바를 탭하면 드롭다운으로 표시됩니다. 검색 결과 개수를 상단에 표시하고(예: "12개 노드 발견"), 결과가 없으면 "검색 결과 없음" 메시지를 표시합니다. 고급 검색 필터(도형 타입, 색상, 날짜)는 Milestone 6에서 추가합니다.

### 키보드 네비게이션

**키보드 네비게이션을 완벽히 지원하여 마우스 없이도 모든 기능을 사용할 수 있습니다.** Tab 키로 포커스를 이동하고, Enter로 선택, Esc로 취소, 화살표 키로 선택한 노드를 이동(1px씩, Shift+화살표는 10px씩), Space로 드래그 모드 진입 등을 지원합니다. 모든 인터랙티브 요소(버튼, 노드, 선)는 포커스 표시가 명확하며(파란 테두리), 스크린 리더가 읽을 수 있도록 aria-label과 role 속성을 적절히 부여합니다.

### 색상 대비 및 스크린 리더 지원

**색상 대비는 WCAG 2.1 AA 기준을 준수하여 시각 장애인도 사용 가능합니다.** 텍스트와 배경색의 대비비는 최소 4.5:1을 유지하고, 손글씨 폰트 색상(#333)은 모든 배경색(노란, 하늘, 민트 등)과 충분한 대비를 보장합니다. 색맹 모드는 Phase 2에서 추가합니다.

**스크린 리더와 음성 안내를 지원하여 시각 장애인도 노드를 탐색할 수 있습니다.** 각 노드는 "동그라미 노드: [내용]" 형식으로 읽히고, 연결된 노드는 "다음 노드로 이동: [대상 노드 내용]"으로 안내됩니다. 포커스 모드에서는 "현재 [노드 이름], [N]개 연결됨"과 같이 상태를 음성으로 알려주고, 노드 생성/삭제 시에도 "노드가 생성되었습니다" 등의 피드백을 제공합니다. VoiceOver(iOS)와 TalkBack(Android) 테스트를 필수로 수행합니다.

**MVP 완성 단계입니다.** 검색 기능과 접근성 지원을 완료하면, 실시간 협업이 가능한 손글씨 노트 애플리케이션이 완성됩니다. 사용자는 브라우저로 즉시 접속하여 여러 워크스페이스를 탐색하고, 임시 닉네임으로 다른 사용자와 실시간으로 노드를 편집할 수 있습니다. 계정 시스템 없이도 협업의 핵심 경험을 제공합니다.

---

## 🎨 Milestone 5: 멀티 디바이스 UX 및 고급 기능 (Week 13-14)

### 목표
태블릿/데스크톱 최적화 + 12가지 도형 완성 + 5가지 선 스타일 + 8가지 색상

### 12가지 도형 타입 완성

**12가지 도형 타입을 모두 구현합니다.** 동그라미, 네모, 둥근네모, 구름, 말풍선, 텍스트만, 별, 하트, 배너, 체크박스, 화살표, 포스트잇은 각각 고유한 시각적 특성을 가지며, strokeWidth는 2px, fillStyle은 solid로 통일합니다. 도형 선택 바텀시트를 구현하여 12가지 도형이 3개 카테고리(기본 6개, 강조 3개, 작업 3개)로 분류되어 표시됩니다.

### 5가지 연결선 스타일

**연결선은 5가지 스타일을 모두 지원합니다.** 점선(기본, strokeLineDash: [5, 5]), 실선(strokeLineDash 없음), 곡선 점선(bezier curve + dash), 화살표 점선(끝에 arrowhead), 양방향 화살표(양쪽에 arrowhead)를 제공합니다. 선 생성 직후 스타일 선택 팝업이 나타나 원하는 스타일을 선택할 수 있고, 선을 다시 탭하면 스타일 변경 메뉴가 나타납니다.

### 8가지 색상 팔레트 완성

**색상 팔레트는 파스텔 톤의 따뜻한 8가지 색상을 제공합니다.** 노란색(#FFE082, 포스트잇 기본), 하늘색(#90CAF9), 민트(#A5D6A7), 주황(#FFAB91), 보라(#CE93D8), 베이지(#BCAAA4), 흰색(#FFFFFF), 투명(테두리만)을 지원합니다.

### 고급 검색 필터

**고급 검색 필터는 노드 타입, 색상, 날짜로 범위를 좁힙니다.** 검색바 오른쪽의 필터 버튼을 탭하면 추가 옵션이 나타나고, "도형 타입"에서 특정 도형만 검색(예: 동그라미만), "색상"에서 특정 배경색 노드만 검색, "날짜"에서 특정 기간에 생성/수정된 노드만 검색할 수 있습니다. 여러 필터를 동시에 적용할 수 있으며(AND 조건), "필터 초기화" 버튼으로 한 번에 해제할 수 있습니다. 검색어를 입력하는 동안 자동완성 제안이 나타나며, 기존 노드 내용에서 자주 등장하는 단어를 우선 추천합니다.

### 100개 노드 성능 최적화

**렌더링 성능은 60fps를 유지해야 하며 100개 노드까지 부드럽게 동작합니다.** 100개 이상의 노드가 있는 경우 가상화(Virtualization)를 적용하여 뷰포트 내의 노드만 렌더링하고, requestAnimationFrame을 활용하여 애니메이션을 최적화합니다. rough.js의 계산이 무거운 경우 캐싱을 활용하여 메인 스레드 블로킹을 방지합니다. Web Worker는 Phase 2에서 추가합니다.

**메모리 사용량은 모바일 디바이스를 고려하여 50MB 이내로 제한합니다.** 메모리 누수를 방지하기 위해 useEffect cleanup, 이벤트 리스너 제거, DOM 참조 해제를 철저히 수행하고, 크롬 개발자 도구의 Memory Profiler로 주기적으로 검증합니다. 큰 SVG 엘리먼트는 재사용 가능한 심볼로 정의하여 메모리 효율을 높입니다.

### 영문 폰트 및 다국어 지원

**영문은 Google Fonts의 Caveat을 사용하여 경쾌하고 친근한 필기체를 표현합니다.** 한글 입력 시 자동으로 나눔손글씨 펜을 적용하고, 영문 입력 시 Caveat을 적용하며, 그 외 문자(일본어, 중국어 등)는 시스템 기본 폰트로 대체됩니다. 이모지는 네이티브 이모지 폰트를 사용하여 플랫폼별로 적절히 렌더링되고, 손글씨 폰트 로딩 실패 시 cursive 제네릭 폰트 패밀리로 대체하여 최소한의 손글씨 느낌을 유지합니다.

### 그리드 설정 확장

**사용자는 설정에서 그리드 간격 조절(16px/20px/32px)을 선택할 수 있습니다.** 다크모드는 Phase 2에서 구현합니다.

**Milestone 5 완료 후에는 풍부한 시각적 표현과 멀티 디바이스 지원을 갖춘 완성도 높은 애플리케이션이 됩니다.** 모바일, 태블릿, 데스크톱 모두에서 최적화된 UX를 제공하며, 100개 이상의 노드도 60fps로 부드럽게 렌더링합니다. 계정 없이도 즉시 협업할 수 있는 완전한 실시간 협업 노트 앱입니다.

---

## 🔮 Phase 2: 오프라인 모드 및 고급 기능 (3-6개월 후)

### 목표
오프라인 모드, PWA, Undo/Redo, 고급 UX 구현

### 오프라인 모드 및 PWA

**Service Worker를 활용한 오프라인 지원을 추가합니다.** 정적 에셋(HTML, CSS, JS, 폰트)을 Service Worker에 캐싱하여 오프라인에서도 앱 실행이 가능하게 합니다. IndexedDB에 노드 데이터를 로컬 저장하고, 네트워크 재연결 시 서버와 자동 동기화합니다. 충돌 발생 시 Last Write Wins 전략으로 해결하거나, 사용자에게 선택권을 제공합니다.

**PWA로 진화하여 홈화면 설치를 지원합니다.** manifest.json을 구성하여 앱 이름, 아이콘, 테마 색상을 정의하고, iOS Safari와 Android Chrome에서 "홈 화면에 추가" 기능을 지원합니다. 푸시 알림으로 워크스페이스 초대, 댓글 알림 등을 전송합니다.

### Undo/Redo 및 Time Travel

**Undo/Redo는 클라이언트 in-memory command stack으로 구현합니다.** 서버의 이벤트 소싱과 별개로, 클라이언트는 사용자의 operation을 메모리에 스택으로 관리하여 빠른 Undo/Redo를 제공합니다. 50단계 제한으로 메모리를 관리하며, Ctrl+Z/Shift+Z 단축키, 두 손가락 스와이프(모바일)를 지원합니다. 브라우저 세션 동안만 유지되며, 새로고침하면 초기화됩니다.

**Time Travel 기능은 서버의 스냅샷 히스토리를 활용합니다.** 워크스페이스의 과거 특정 시점으로 되돌아가려면 서버의 workspace_snapshots 테이블에서 해당 날짜의 스냅샷을 조회하여 복원합니다. 30일간 보관된 스냅샷을 활용하여 일별 Time Travel이 가능하며, 복원 시 새로운 워크스페이스로 복사하거나 현재 워크스페이스를 덮어쓸 수 있습니다.

**템플릿 저장 및 불러오기를 추가합니다.** 자주 사용하는 노드 구조를 템플릿으로 저장하고, 새 워크스페이스에 적용할 수 있습니다.

**자동 백업 및 버전 히스토리를 구현합니다.** 매일 자동으로 서버에 백업하고, 버전 히스토리를 통해 과거 시점으로 되돌리기(Time Travel)를 지원합니다. 데이터 삭제 시 휴지통에 30일간 보관 후 영구 삭제합니다.

**다크모드를 추가합니다.** 배경을 #1e1e1e, 그리드를 #333333으로 변경하여 눈의 피로를 줄입니다.

**색맹 모드를 추가합니다.** 색상 외에 패턴이나 아이콘으로도 구분할 수 있도록 테두리 스타일을 다양화하고, 연결선도 점선/실선/이중선 등으로 타입을 구별합니다.

**태블릿 Split View를 지원합니다.** 두 개의 워크스페이스를 나란히 보며 노드를 복사할 수 있습니다.

**멀티 터치 회전 및 확대를 추가합니다.** 여러 노드를 동시에 확대/축소하거나 회전할 수 있습니다.

**선의 곡률 조절을 추가합니다.** 중간점을 드래그하여 베지어 곡선을 조절할 수 있습니다.

**Web Worker를 활용합니다.** rough.js의 계산이 무거운 경우 백그라운드 처리하여 메인 스레드 블로킹을 방지합니다.

**노드 그룹화를 지원합니다.** 여러 노드를 그룹으로 묶어 일괄 이동, 스타일 변경이 가능합니다.

**색연필 느낌의 컬러 선을 추가합니다.** 연결선에 다양한 색상을 적용할 수 있습니다.

**이모지 추가 기능을 확장합니다.** 노드에 여러 이모지를 추가하고, 이모지 검색을 지원합니다.

**빠른 연결 팝업을 추가합니다.** 노드 생성 직후 "최근 노드와 연결하시겠어요?" 팝업으로 빠르게 관계를 맺을 수 있습니다.

**마크다운 지원을 추가합니다.** 노드 내용에 기본 마크다운 서식(볼드, 이탤릭 등)을 적용할 수 있습니다.

---

## 🌟 Phase 3: AI 및 고급 그래프 기능 (6개월 이후)

### 목표
AI 기반 기능, 고급 그래프 분석, 리치 미디어 지원

### AI 기능

**AI 기반 자동 연결 제안을 구현합니다.** 노드 내용을 분석하여 관련성이 높은 노드를 자동으로 연결 제안합니다.

**요약 생성 기능을 추가합니다.** 여러 노드를 선택하면 전체 내용을 요약하여 새 노드로 생성합니다.

**관련 노드 추천을 제공합니다.** 현재 노드와 관련된 다른 노드를 추천하여 사고의 확장을 돕습니다.

### 고급 그래프 기능

**노드 간 최단 경로 찾기를 구현합니다.** 두 노드를 선택하면 최단 연결 경로를 하이라이트합니다.

**클러스터 감지를 추가합니다.** 밀집된 노드 그룹을 자동으로 감지하여 시각화합니다.

**그래프 분석을 제공합니다.** 허브 노드(연결이 많은 노드), 고립된 노드 등을 분석하여 인사이트를 제공합니다.

**자동 레이아웃 제안을 구현합니다.** Force-directed layout, Hierarchical layout 등 자동 배치 알고리즘을 제공합니다.

### 리치 미디어 지원

**이미지, 파일 첨부를 지원합니다.** 노드 내 이미지 업로드, 파일 첨부, PDF 임베딩 등을 구현합니다.

**리치 텍스트 편집을 추가합니다.** 볼드, 이탤릭, 하이라이트, 링크 등의 리치 텍스트 서식을 제공합니다.

---

**이 로드맵은 Knotly 프로젝트가 최소 프로토타입에서 실시간 협업 도구로 진화하는 과정을 보여줍니다.**
각 마일스톤은 독립적으로 데모 가능한 상태를 목표로 하며, MVP(Milestone 1-5, 14주)까지 빠르게 도달하여 실사용자 피드백을 받는 것을 우선합니다.

**핵심 기술 전략: gRPC + Protobuf로 타입 안전성과 고성능을 확보하고, 순수 PostgreSQL로 데이터베이스 원리를 깊이 학습하며, Matt Weidner의 서버 주도 operation ordering 방식으로 CRDT 없이 실시간 협업을 구현합니다. 계정 시스템 없이도 즉시 협업할 수 있는 마찰 없는 사용자 경험을 MVP 단계부터 제공합니다.**
