기술 스택: React 18과 TypeScript를 사용한다. Tailwind CSS의 반응형 유틸리티 클래스를 활용한다. react-use-gesture 라이브러리를 사용하여 롱프레스를 감지한다. pnpm add @use-gesture/react를 실행한다. rough.js의 curve 메서드로 베지어 곡선을 렌더링한다. SVG marker 요소로 화살표를 정의한다. window.visualViewport API로 소프트 키보드를 감지한다. Lighthouse를 사용하여 모바일 성능을 측정한다. Chrome DevTools의 Device Mode로 다양한 화면 크기를 테스트한다.

아키텍처 개요: ShapeMenu 컴포넌트를 만들어 도형 선택 UI를 제공한다. FAB 버튼의 useLongPress 훅으로 롱프레스를 감지하고 메뉴를 표시한다. ColorPalette 컴포넌트를 만들어 8가지 색상을 그리드로 렌더링한다. LineStyleMenu 컴포넌트를 만들어 선 스타일과 화살표 옵션을 제공한다. ShapeRenderer 유틸리티 클래스를 만들어 도형 타입별로 rough.js 렌더링 로직을 캡슐화한다. renderCircle, renderRectangle, renderDiamond, renderCloud 메서드를 제공한다. EdgeRenderer 유틸리티 클래스를 만들어 선 스타일별로 렌더링 로직을 캡슐화한다. renderSolid, renderDashed, renderCurved 메서드를 제공한다. ResponsiveLayout 컨텍스트를 만들어 isMobile, isTablet, isDesktop 상태를 전역으로 제공한다. KeyboardManager 훅을 만들어 소프트 키보드 상태를 감지하고 캔버스를 자동 스크롤한다.

구현 순서 1단계: Zustand 스토어를 확장하여 도형, 색상, 선 스타일 상태를 추가한다. src/store/canvasStore.ts를 수정한다. selectedShapeType: 'circle' | 'rectangle' | 'diamond' | 'cloud'를 추가한다. 기본값은 'circle'이다. selectedLineStyle: 'solid' | 'dashed' | 'curved'를 추가한다. 기본값은 'dashed'이다. selectedArrowType: 'none' | 'single' | 'double'를 추가한다. 기본값은 'none'이다. shapeMenuOpen: boolean을 추가한다. 기본값은 false이다. setSelectedShapeType: (type) => void 액션을 추가한다. set({selectedShapeType: type})를 실행한다. setSelectedLineStyle: (style) => void 액션을 추가한다. setSelectedArrowType: (type) => void 액션을 추가한다. openShapeMenu: () => void 액션을 추가하여 set({shapeMenuOpen: true})를 실행한다. closeShapeMenu: () => void 액션을 추가한다. createNode 액션을 수정하여 type 파라미터를 추가한다. const newNode = {id: uuid(), position: {x, y}, content, type: get().selectedShapeType, style: {...}, createdAt: Date.now(), updatedAt: Date.now()}로 생성한다. createEdge 액션을 수정하여 lineStyle과 arrowType 파라미터를 추가한다. const newEdge = {id: uuid(), fromId, toId, lineStyle: get().selectedLineStyle, arrowType: get().selectedArrowType, createdAt: Date.now()}로 생성한다.

구현 순서 2단계: ShapeMenu 컴포넌트를 구현한다. src/components/ShapeMenu.tsx 파일을 생성한다. import { useCanvasStore } from '../store/canvasStore'를 추가한다. const shapeMenuOpen = useCanvasStore((state) => state.shapeMenuOpen)로 상태를 구독한다. const closeShapeMenu = useCanvasStore((state) => state.closeShapeMenu)로 액션을 가져온다. const setSelectedShapeType = useCanvasStore((state) => state.setSelectedShapeType)로 액션을 가져온다. const shapes = [{type: 'circle', icon: '⭕', label: '동그라미'}, {type: 'rectangle', icon: '⬜', label: '네모'}, {type: 'diamond', icon: '◇', label: '다이아몬드'}, {type: 'cloud', icon: '☁️', label: '구름'}]를 정의한다. const handleShapeSelect = (type: string) => { setSelectedShapeType(type); closeShapeMenu(); }를 구현한다. 렌더링은 {shapeMenuOpen && <div className="fixed bottom-24 right-4 bg-white rounded-lg shadow-xl p-4 flex gap-4"><\>각 도형 아이콘을 버튼으로 렌더링한다. <button key={shape.type} onClick={() => handleShapeSelect(shape.type)} className="w-16 h-16 flex flex-col items-center justify-center hover:bg-gray-100 rounded" aria-label={shape.label}><span className="text-3xl">{shape.icon}</span><span className="text-xs mt-1">{shape.label}</span></button>로 작성한다. FAB 버튼에 useLongPress 훅을 추가한다. src/components/FABButton.tsx를 수정한다. import { useLongPress } from '@use-gesture/react'를 추가한다. const bind = useLongPress(() => { useCanvasStore.getState().openShapeMenu(); }, {threshold: 500})를 정의한다. threshold: 500은 500ms 롱프레스를 의미한다. <button {...bind()} className="..." aria-label="새 노드 추가">+</button>로 적용한다.

구현 순서 3단계: ColorPalette 컴포넌트를 구현한다. src/components/ColorPalette.tsx 파일을 생성한다. const COLORS = [{name: '노란색', value: '#FFE082'}, {name: '하늘색', value: '#90CAF9'}, {name: '민트', value: '#A5D6A7'}, {name: '핑크', value: '#F48FB1'}, {name: '보라', value: '#CE93D8'}, {name: '주황', value: '#FFAB91'}, {name: '연두', value: '#C5E1A5'}, {name: '회색', value: '#E0E0E0'}]를 정의한다. props로 nodeId와 currentColor를 받는다. const handleColorSelect = (color: string) => { useCanvasStore.getState().updateNode(nodeId, {style: {backgroundColor: color}}); onClose(); }를 구현한다. 렌더링은 <div className="grid grid-cols-4 gap-2 p-4">로 2행 4열 그리드를 만든다. {COLORS.map(color => <button key={color.value} onClick={() => handleColorSelect(color.value)} className="w-12 h-12 rounded-full border-2 flex items-center justify-center" style={{backgroundColor: color.value}}>{currentColor === color.value && <span className="text-white text-xl">✓</span>}</button>)}로 렌더링한다. ContextMenu 컴포넌트를 수정하여 "색상 변경" 옵션을 추가한다. src/components/ContextMenu.tsx를 수정한다. const [colorPaletteOpen, setColorPaletteOpen] = useState(false)를 추가한다. <button onClick={() => setColorPaletteOpen(true)}>색상 변경</button>을 메뉴에 추가한다. {colorPaletteOpen && <ColorPalette nodeId={nodeId} currentColor={currentColor} onClose={() => setColorPaletteOpen(false)} />}를 렌더링한다.

구현 순서 4단계: LineStyleMenu 컴포넌트를 구현한다. src/components/LineStyleMenu.tsx 파일을 생성한다. const selectedLineStyle = useCanvasStore((state) => state.selectedLineStyle)로 상태를 구독한다. const selectedArrowType = useCanvasStore((state) => state.selectedArrowType)로 상태를 구독한다. const setSelectedLineStyle = useCanvasStore((state) => state.setSelectedLineStyle)로 액션을 가져온다. const setSelectedArrowType = useCanvasStore((state) => state.setSelectedArrowType)로 액션을 가져온다. const lineStyles = [{type: 'solid', label: '실선', preview: '—'}, {type: 'dashed', label: '점선', preview: '- -'}, {type: 'curved', label: '곡선', preview: '~'}]를 정의한다. const arrowTypes = [{type: 'none', label: '없음', preview: '—'}, {type: 'single', label: '단방향', preview: '→'}, {type: 'double', label: '양방향', preview: '↔'}]를 정의한다. 렌더링은 <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-xl p-4 flex gap-4">로 화면 하단 중앙에 배치한다. <div className="flex flex-col gap-2"><label className="text-xs font-semibold">선 스타일</label><div className="flex gap-2">{lineStyles.map(style => <button key={style.type} onClick={() => setSelectedLineStyle(style.type)} className={`px-3 py-2 rounded ${selectedLineStyle === style.type ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}>{style.preview} {style.label}</button>)}</div></div>로 작성한다. 화살표 옵션도 동일하게 작성한다. ConnectModeButton 컴포넌트를 수정하여 연결 모드 활성화 시 LineStyleMenu를 표시한다. src/components/ConnectModeButton.tsx를 수정한다. const connectMode = useCanvasStore((state) => state.connectMode)를 구독한다. {connectMode && <LineStyleMenu />}를 렌더링한다.

구현 순서 5단계: ShapeRenderer 유틸리티를 구현한다. src/utils/shapeRenderer.ts 파일을 생성한다. import rough from 'roughjs'를 추가한다. export class ShapeRenderer { private rc: any; constructor(svg: SVGSVGElement) { this.rc = rough.svg(svg); } renderCircle(x: number, y: number, size: number, options: any) { return this.rc.circle(x, y, size, options); } renderRectangle(x: number, y: number, width: number, height: number, options: any) { return this.rc.rectangle(x - width / 2, y - height / 2, width, height, options); } renderDiamond(x: number, y: number, size: number, options: any) { const points = [[x, y - size / 2], [x + size / 2, y], [x, y + size / 2], [x - size / 2, y]]; return this.rc.polygon(points, options); } renderCloud(x: number, y: number, size: number, options: any) { const group = document.createElementNS('http://www.w3.org/2000/svg', 'g'); const ellipse1 = this.rc.ellipse(x - size / 3, y, size / 1.5, size / 2, options); const ellipse2 = this.rc.ellipse(x + size / 3, y, size / 1.5, size / 2, options); const ellipse3 = this.rc.ellipse(x, y - size / 4, size / 1.2, size / 2.5, options); group.appendChild(ellipse1); group.appendChild(ellipse2); group.appendChild(ellipse3); return group; } }를 구현한다. Node 컴포넌트를 수정하여 ShapeRenderer를 사용한다. src/components/Node.tsx를 수정한다. useEffect(() => { if (!svgRef.current) return; const renderer = new ShapeRenderer(svgRef.current); let shape; if (node.type === 'circle') { shape = renderer.renderCircle(node.position.x, node.position.y, 150, {fill: node.style.backgroundColor, stroke: node.style.strokeColor, strokeWidth: node.style.strokeWidth}); } else if (node.type === 'rectangle') { shape = renderer.renderRectangle(node.position.x, node.position.y, 150, 100, {...}); } else if (node.type === 'diamond') { shape = renderer.renderDiamond(node.position.x, node.position.y, 150, {...}); } else if (node.type === 'cloud') { shape = renderer.renderCloud(node.position.x, node.position.y, 150, {...}); } svgRef.current.appendChild(shape); }, [node.type, node.style])로 수정한다.

구현 순서 6단계: EdgeRenderer 유틸리티를 구현한다. src/utils/edgeRenderer.ts 파일을 생성한다. export class EdgeRenderer { private rc: any; constructor(svg: SVGSVGElement) { this.rc = rough.svg(svg); } renderSolid(x1: number, y1: number, x2: number, y2: number, options: any) { return this.rc.line(x1, y1, x2, y2, options); } renderDashed(x1: number, y1: number, x2: number, y2: number, options: any) { return this.rc.line(x1, y1, x2, y2, {...options, strokeLineDash: [5, 5]}); } renderCurved(x1: number, y1: number, x2: number, y2: number, options: any) { const dx = (x2 - x1) / 3; const dy = (y2 - y1) / 3; const cx1 = x1 + dx; const cy1 = y1 + dy; const cx2 = x1 + 2 * dx; const cy2 = y1 + 2 * dy; const points = [[x1, y1], [cx1, cy1], [cx2, cy2], [x2, y2]]; return this.rc.curve(points, options); } addArrow(svg: SVGSVGElement, edgeId: string, arrowType: string) { const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svg.firstChild); if (arrowType === 'single' || arrowType === 'double') { const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', `arrowhead-${edgeId}`); marker.setAttribute('markerWidth', '10'); marker.setAttribute('markerHeight', '10'); marker.setAttribute('refX', '9'); marker.setAttribute('refY', '3'); marker.setAttribute('orient', 'auto'); const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); polygon.setAttribute('points', '0 0, 10 3, 0 6'); polygon.setAttribute('fill', '#000'); marker.appendChild(polygon); defs.appendChild(marker); } if (arrowType === 'double') { const markerReverse = marker.cloneNode(true); markerReverse.setAttribute('id', `arrowhead-reverse-${edgeId}`); markerReverse.setAttribute('orient', 'auto-start-reverse'); defs.appendChild(markerReverse); } } }를 구현한다. Edge 컴포넌트를 수정하여 EdgeRenderer를 사용한다. src/components/Edge.tsx를 수정한다. useEffect(() => { if (!svgRef.current) return; const renderer = new EdgeRenderer(svgRef.current); let line; if (edge.lineStyle === 'solid') { line = renderer.renderSolid(x1, y1, x2, y2, {stroke: '#000', strokeWidth: 2}); } else if (edge.lineStyle === 'dashed') { line = renderer.renderDashed(x1, y1, x2, y2, {stroke: '#000', strokeWidth: 2}); } else if (edge.lineStyle === 'curved') { line = renderer.renderCurved(x1, y1, x2, y2, {stroke: '#000', strokeWidth: 2}); } if (edge.arrowType === 'single') { line.setAttribute('marker-end', `url(#arrowhead-${edge.id})`); renderer.addArrow(svgRef.current, edge.id, 'single'); } else if (edge.arrowType === 'double') { line.setAttribute('marker-start', `url(#arrowhead-reverse-${edge.id})`); line.setAttribute('marker-end', `url(#arrowhead-${edge.id})`); renderer.addArrow(svgRef.current, edge.id, 'double'); } svgRef.current.appendChild(line); }, [edge.lineStyle, edge.arrowType])로 수정한다.

구현 순서 7단계: 반응형 레이아웃을 구현한다. src/contexts/ResponsiveContext.tsx 파일을 생성한다. import { createContext, useContext, useState, useEffect } from 'react'를 추가한다. const ResponsiveContext = createContext({ isMobile: false, isTablet: false, isDesktop: false })를 생성한다. export const ResponsiveProvider = ({ children }) => { const [isMobile, setIsMobile] = useState(false); const [isTablet, setIsTablet] = useState(false); const [isDesktop, setIsDesktop] = useState(false); useEffect(() => { const handleResize = () => { const width = window.innerWidth; setIsMobile(width < 768); setIsTablet(width >= 768 && width < 1024); setIsDesktop(width >= 1024); }; handleResize(); window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize); }, []); return <ResponsiveContext.Provider value={{ isMobile, isTablet, isDesktop }}>{children}</ResponsiveContext.Provider>; }를 구현한다. export const useResponsive = () => useContext(ResponsiveContext)를 내보낸다. App.tsx를 수정하여 ResponsiveProvider로 래핑한다. import { ResponsiveProvider } from './contexts/ResponsiveContext'를 추가한다. <ResponsiveProvider><Canvas /><FABButton />...</ResponsiveProvider>로 래핑한다. 컴포넌트에서 const { isMobile, isTablet, isDesktop } = useResponsive()로 상태를 가져온다. {isMobile && <BottomSheet />} {isDesktop && <Sidebar />}처럼 조건부 렌더링한다.

구현 순서 8단계: 소프트 키보드 대응을 구현한다. src/hooks/useKeyboardManager.ts 파일을 생성한다. import { useEffect } from 'react'를 추가한다. import { useCanvasStore } from '../store/canvasStore'를 추가한다. export const useKeyboardManager = () => { useEffect(() => { const handleResize = () => { if (!window.visualViewport) return; const viewportHeight = window.visualViewport.height; const keyboardHeight = window.innerHeight - viewportHeight; if (keyboardHeight > 100) { const editingNodeId = useCanvasStore.getState().editingNodeId; if (!editingNodeId) return; const node = useCanvasStore.getState().nodes.find(n => n.id === editingNodeId); if (!node) return; const nodeY = node.position.y; const viewportMiddle = viewportHeight / 2; if (nodeY > viewportMiddle) { const pan = useCanvasStore.getState().pan; useCanvasStore.getState().setPan({...pan, y: pan.y - (nodeY - viewportMiddle)}); } } }; if (window.visualViewport) { window.visualViewport.addEventListener('resize', handleResize); return () => window.visualViewport.removeEventListener('resize', handleResize); } }, []); }를 구현한다. Canvas 컴포넌트에서 useKeyboardManager()를 호출한다. import { useKeyboardManager } from '../hooks/useKeyboardManager'를 추가한다. useKeyboardManager()를 컴포넌트 내부에서 호출한다.

구현 순서 9단계: 터치 타겟 크기를 조정한다. Tailwind CSS의 min-w-11, min-h-11 클래스를 사용하여 44x44px 이상을 보장한다. 11은 44px이다(Tailwind는 4px 단위). FAB 버튼을 수정한다. <button className="w-14 h-14 ..." aria-label="새 노드 추가">+</button>로 56x56px로 설정한다. 14는 56px이다. 노드 컨텍스트 메뉴 버튼을 수정한다. <button className="min-w-11 min-h-11 px-4 py-2 ..." />로 최소 44px를 보장한다. 검색 결과 항목을 수정한다. <div className="p-4 hover:bg-gray-100 cursor-pointer min-h-16 ..." />로 최소 64px 높이를 설정한다. 16은 64px이다. 색상 팔레트 버튼을 수정한다. <button className="w-12 h-12 ..." />로 48x48px로 설정한다. 12는 48px이다.

구현 순서 10단계: Protobuf 스키마를 확장한다. proto/knotly.proto 파일을 수정한다. message Node에 string type = 9를 추가한다. circle, rectangle, diamond, cloud 값을 가진다. message Edge에 string line_style = 6을 추가한다. solid, dashed, curved 값을 가진다. message Edge에 string arrow_type = 7을 추가한다. none, single, double 값을 가진다. protoc 컴파일러를 다시 실행하여 TypeScript 코드를 재생성한다. pnpm run proto:build를 실행한다. gRPC 서버의 WorkspaceService를 수정하여 새 필드를 처리한다. createNode 메서드에서 data.type을 읽어 operation_data에 포함한다. createEdge 메서드에서 data.line_style, data.arrow_type을 읽어 operation_data에 포함한다.

구현 순서 11단계: 모바일 성능을 최적화한다. rough.js의 roughness를 모바일에서 낮춘다. const roughness = isMobile ? 0.8 : 1.2로 조건부 설정한다. 낮은 roughness는 계산이 적어 성능이 좋다. 노드 수가 많을 때 가상 스크롤을 적용한다. react-window 라이브러리를 설치한다. pnpm add react-window를 실행한다. 검색 결과 목록을 FixedSizeList로 래핑한다. import { FixedSizeList } from 'react-window'를 추가한다. <FixedSizeList height={400} itemCount={results.length} itemSize={64} width="100%">{({ index, style }) => <div style={style}>{results[index].content}</div>}</FixedSizeList>로 렌더링한다. 이미지 로딩 최적화는 필요 없다. Knotly는 이미지를 사용하지 않고 SVG만 사용한다. useMemo와 useCallback을 추가하여 불필요한 리렌더링을 방지한다. const renderedNodes = useMemo(() => nodes.map(node => <Node key={node.id} node={node} />), [nodes])로 메모이제이션한다.

구현 순서 12단계: 모바일 테스트를 수행한다. Chrome DevTools의 Device Mode를 연다. Ctrl+Shift+M(Windows) 또는 Cmd+Shift+M(macOS)을 누른다. iPhone SE(375x667)를 선택하고 테스트한다. FAB 버튼을 500ms 롱프레스하여 도형 메뉴가 나타나는지 확인한다. 노드를 생성하고 편집 시 키보드가 올라와도 노드가 가려지지 않는지 확인한다. iPad(768x1024)를 선택하고 테스트한다. 사이드바가 토글되는지 확인한다. Desktop(1920x1080)을 선택하고 테스트한다. 사이드바가 항상 표시되는지 확인한다. Throttling을 4x CPU slowdown으로 설정하여 저사양 모바일을 시뮬레이션한다. Performance 탭에서 프로파일링을 수행하여 60fps를 유지하는지 확인한다. Lighthouse를 실행하여 모바일 Performance 점수가 90 이상인지 확인한다. 실제 iPhone 또는 Android 기기에서 테스트한다. Chrome Remote Debugging으로 연결하여 개발자 도구를 사용한다. USB로 기기를 연결하고 chrome://inspect에 접속한다. 터치 타겟이 44x44px 이상인지 확인한다. 소프트 키보드가 올라올 때 자동 스크롤이 작동하는지 확인한다.

기술적 제약사항: window.visualViewport API는 iOS Safari 13 이상, Android Chrome 61 이상에서 지원한다. 구형 브라우저를 위한 폴백은 window.addEventListener('resize')로 처리한다. rough.js의 curve 메서드는 베지어 곡선을 지원하지만 3차 베지어만 가능하다. 고차 곡선은 지원하지 않는다. SVG marker는 fill 색상만 설정 가능하고 stroke는 지원하지 않는다. 화살촉은 단색으로만 렌더링된다. Tailwind CSS의 브레이크포인트는 min-width 기준이다. max-width 기반으로 변경하려면 screens: {'max-md': {max: '767px'}}를 tailwind.config.js에 추가한다. react-use-gesture의 useLongPress는 터치와 마우스를 모두 지원한다. 하지만 일부 Android 브라우저에서 컨텍스트 메뉴가 먼저 나타날 수 있으므로 e.preventDefault()를 호출해야 한다. 다이아몬드 도형의 점 계산은 회전 각도를 고려하지 않는다. 45도 회전된 정사각형 모양만 지원한다. 구름 도형의 ellipse 3개는 고정 비율로 배치된다. 사용자가 구름 모양을 커스터마이징할 수 없다. Constitution 원칙에 따라 throw를 사용하지 않는다. 노드나 엣지를 찾지 못했을 때 early return한다.

참고 자료: rough.js curve 메서드 문서 https://github.com/rough-stuff/rough/wiki/Documentation#curve에서 베지어 곡선 사용법을 확인한다. points 배열은 [[x1, y1], [cx1, cy1], [cx2, cy2], [x2, y2]] 형태이다. SVG marker 요소 문서 https://developer.mozilla.org/en-US/docs/Web/SVG/Element/marker에서 markerWidth, markerHeight, refX, refY, orient 속성을 확인한다. orient="auto"는 선의 각도에 맞춰 화살표를 회전한다. Tailwind CSS 반응형 디자인 문서 https://tailwindcss.com/docs/responsive-design에서 브레이크포인트 사용법을 확인한다. sm:, md:, lg: 접두사를 사용한다. window.visualViewport API 문서 https://developer.mozilla.org/en-US/docs/Web/API/VisualViewport에서 height, scale, offsetTop 속성을 확인한다. react-use-gesture 문서 https://use-gesture.netlify.app/docs/gestures/#uselongpress에서 threshold, onCancel 옵션을 확인한다. Lighthouse 모바일 성능 측정 가이드 https://developer.chrome.com/docs/lighthouse/performance/에서 First Contentful Paint, Speed Index, Time to Interactive 지표를 확인한다. Chrome DevTools Device Mode 가이드 https://developer.chrome.com/docs/devtools/device-mode/에서 다양한 디바이스 시뮬레이션 방법을 확인한다. react-window 가이드 https://react-window.vercel.app/에서 FixedSizeList, VariableSizeList 사용법을 확인한다.
