기술 스택: 기존 React 18, TypeScript, Zustand, @use-gesture/react, Tailwind CSS, rough.js 스택을 유지한다. 추가로 js-yaml 라이브러리를 설치하여 YAML frontmatter 파싱과 직렬화를 처리한다. pnpm add js-yaml @types/js-yaml를 실행한다. File System Access API를 사용하여 브라우저 네이티브 파일 I/O를 구현한다. Chromium 기반 브라우저(Chrome, Edge, Opera)에서 showOpenFilePicker(), showSaveFilePicker(), createWritable() 메서드를 활용한다. Safari, Firefox는 폴백으로 file input과 Blob download를 사용한다.

아키텍처 개요: 파일 I/O 레이어를 새로 추가한다. src/utils/fileIO.ts 파일을 생성하여 loadKnotlyFile(fileHandle: FileSystemFileHandle): Promise<{tokens, nodes, edges}>, saveKnotlyFile(fileHandle: FileSystemFileHandle, state: CanvasStore): Promise<void> 함수를 구현한다. 토큰 시스템 레이어를 추가한다. src/utils/tokenParser.ts 파일을 생성하여 parseTokens(style: string, tokenDefinitions: TokenDefinitions): StyleObject, resolveToken(tokenName: string, tokenDefinitions: TokenDefinitions): StyleObject 함수를 구현한다. Zustand store를 확장한다. canvasStore.ts에 tokenDefinitions: TokenDefinitions, currentFilePath: string | null, hasUnsavedChanges: boolean, recentFiles: string[] 필드를 추가한다. Node 타입의 style 필드를 {backgroundColor: string, ...} 객체에서 "color-blue h4 neat" 문자열로 변경한다. 기존 NodeComponent는 렌더링 시 parseTokens를 호출하여 스타일 객체를 생성한다. 시작 화면 컴포넌트를 추가한다. src/components/StartScreen.tsx를 생성하여 새 노트, 파일 열기, 최근 파일 목록을 렌더링한다. 스타일 선택 패널 컴포넌트를 추가한다. src/components/StylePanel.tsx를 생성하여 카테고리별 토큰 버튼을 렌더링하고 조합 문자열을 관리한다. 타이틀바 컴포넌트를 추가한다. src/components/TitleBar.tsx를 생성하여 파일명과 저장 상태를 표시한다.

파일 I/O 구현: src/utils/fileIO.ts 파일을 생성한다. loadKnotlyFile 함수를 구현한다. async function loadKnotlyFile(fileHandle: FileSystemFileHandle) {const file = await fileHandle.getFile(); const text = await file.text(); const [frontmatterText, ...bodyParts] = text.split('---'); const frontmatter = yaml.load(frontmatterText); const body = bodyParts.join('---').trim(); const nodes = frontmatter.nodes.map(n => ({...n, content: extractContent(body, n.id)})); return {tokens: frontmatter.tokens, nodes, edges: frontmatter.edges.map(([from, to]) => ({id: uuid(), fromId: from, toId: to, lineStyle: 'dashed', createdAt: Date.now()}))};}를 작성한다. extractContent 함수는 정규식으로 [id] 섹션을 찾는다. function extractContent(body: string, id: string) {const regex = new RegExp(`\\[${id}\\]\\n([\\s\\S]*?)(?=\\n\\[|$)`); const match = body.match(regex); return match ? match[1].trim() : '';}를 작성한다. saveKnotlyFile 함수를 구현한다. async function saveKnotlyFile(fileHandle: FileSystemFileHandle, state: CanvasStore) {const frontmatter = {tokens: state.tokenDefinitions, nodes: state.nodes.map(n => ({id: n.id, pos: [n.position.x, n.position.y], style: n.style})), edges: state.edges.map(e => [e.fromId, e.toId])}; const frontmatterText = yaml.dump(frontmatter); const body = state.nodes.map(n => `[${n.id}]\\n${n.content}\\n`).join('\\n'); const content = `---\\n${frontmatterText}---\\n\\n${body}`; const writable = await fileHandle.createWritable(); await writable.write(content); await writable.close();}를 작성한다. showOpenFilePicker와 showSaveFilePicker를 래핑하는 헬퍼 함수를 만든다. async function openFile() {const [fileHandle] = await window.showOpenFilePicker({types: [{description: 'Knotly Files', accept: {'text/markdown': ['.knotly.md']}}]}); return fileHandle;}와 async function saveFile(fileHandle?: FileSystemFileHandle) {if (!fileHandle) fileHandle = await window.showSaveFilePicker({suggestedName: 'my-note.knotly.md', types: [{description: 'Knotly Files', accept: {'text/markdown': ['.knotly.md']}}]}); return fileHandle;}를 작성한다.

토큰 파서 구현: src/utils/tokenParser.ts 파일을 생성한다. TokenDefinitions 타입을 정의한다. type TokenDefinitions = {[name: string]: StyleObject | string}; type StyleObject = {stroke?: string; fill?: string; width?: number; height?: number; fontSize?: number; fontWeight?: number; strokeWidth?: number; roughness?: number;}를 작성한다. parseTokens 함수를 구현한다. function parseTokens(style: string, tokenDefinitions: TokenDefinitions): StyleObject {const tokens = style.split(' ').filter(Boolean); let result: StyleObject = {}; for (const token of tokens) {const resolved = resolveToken(token, tokenDefinitions); Object.assign(result, resolved);} return result;}를 작성한다. resolveToken 함수는 재귀적으로 토큰을 파싱한다. function resolveToken(tokenName: string, tokenDefinitions: TokenDefinitions): StyleObject {const value = tokenDefinitions[tokenName]; if (!value) return {}; if (typeof value === 'string') return parseTokens(value, tokenDefinitions); return value;}를 작성한다. 기본 토큰 라이브러리를 상수로 정의한다. export const DEFAULT_TOKENS: TokenDefinitions = {'color-blue': {stroke: '#2563eb', fill: '#dbeafe'}, 'color-red': {stroke: '#dc2626', fill: '#fee2e2'}, 'color-mint': {stroke: '#059669', fill: '#d1fae5'}, 'color-yellow': {stroke: '#ca8a04', fill: '#fef9c3'}, 'color-gray': {stroke: '#64748b', fill: '#f1f5f9'}, 'color-purple': {stroke: '#7c3aed', fill: '#ede9fe'}, 'color-orange': {stroke: '#ea580c', fill: '#fed7aa'}, 'color-pink': {stroke: '#db2777', fill: '#fce7f3'}, h1: {width: 320, height: 200, fontSize: 24}, h2: {width: 280, height: 180, fontSize: 20}, h3: {width: 240, height: 160, fontSize: 18}, h4: {width: 200, height: 140, fontSize: 16}, h5: {width: 180, height: 120, fontSize: 14}, h6: {width: 160, height: 100, fontSize: 12}, smooth: {roughness: 0.5}, neat: {roughness: 1.0}, rough: {roughness: 1.5}, sketchy: {roughness: 2.0}, messy: {roughness: 2.5}, thin: {strokeWidth: 1}, normal: {strokeWidth: 2}, thick: {strokeWidth: 3}, bold: {strokeWidth: 4}, dashed: {strokeStyle: 'dashed'}, solid: {strokeStyle: 'solid'}}를 작성한다.

Zustand 스토어 확장: src/store/canvasStore.ts를 수정한다. 새 필드를 추가한다. tokenDefinitions: TokenDefinitions = DEFAULT_TOKENS, currentFilePath: string | null = null, hasUnsavedChanges: boolean = false, recentFiles: string[] = []를 초기 상태에 추가한다. 새 액션을 추가한다. loadFile: async (fileHandle: FileSystemFileHandle) => {const data = await loadKnotlyFile(fileHandle); set({tokenDefinitions: {...DEFAULT_TOKENS, ...data.tokens}, nodes: data.nodes, edges: data.edges, currentFilePath: fileHandle.name, hasUnsavedChanges: false});}를 작성한다. saveFile: async (fileHandle?: FileSystemFileHandle) => {const state = get(); if (!fileHandle && !state.currentFilePath) fileHandle = await saveFile(); await saveKnotlyFile(fileHandle, state); set({currentFilePath: fileHandle.name, hasUnsavedChanges: false}); addRecentFile(fileHandle.name);}를 작성한다. markDirty: () => set({hasUnsavedChanges: true})를 작성한다. 기존 createNode, updateNode, moveNode, deleteNode, createEdge, deleteEdge 액션에서 markDirty()를 호출하도록 수정한다. addRecentFile: (path: string) => {const recent = get().recentFiles.filter(p => p !== path); set({recentFiles: [path, ...recent].slice(0, 5)}); localStorage.setItem('knotly-recent-files', JSON.stringify(get().recentFiles));}를 작성한다. Node 타입의 style 필드를 문자열로 변경한다. interface Node {id: string; position: {x: number; y: number}; content: string; type: 'circle'; style: string; createdAt: number; updatedAt: number;}로 수정한다. createNode에서 기본 스타일을 style: "color-yellow h4 neat"로 설정한다.

NodeComponent 리팩토링: src/components/NodeComponent.tsx를 수정한다. useCanvasStore에서 tokenDefinitions를 가져온다. const {tokenDefinitions} = useCanvasStore()를 추가한다. parseTokens를 호출하여 스타일 객체를 생성한다. const resolvedStyle = parseTokens(node.style, tokenDefinitions)를 계산한다. rough.js 렌더링에 resolvedStyle을 사용한다. const rc = rough.svg(svgRef.current); const circle = rc.circle(0, 0, resolvedStyle.width || 120, {stroke: resolvedStyle.stroke || '#000', fill: resolvedStyle.fill || '#FFE082', strokeWidth: resolvedStyle.strokeWidth || 2, roughness: resolvedStyle.roughness || 1.0})를 작성한다. SVG text 요소에 fontSize를 적용한다. text fontSize={resolvedStyle.fontSize || 16}를 추가한다. 우클릭 이벤트를 추가한다. onContextMenu={(e) => {e.preventDefault(); setShowStylePanel(true);}}를 설정한다. const [showStylePanel, setShowStylePanel] = useState(false)를 추가하고 조건부로 StylePanel을 렌더링한다. {showStylePanel && <StylePanel nodeId={node.id} currentStyle={node.style} onClose={() => setShowStylePanel(false)} />}를 추가한다.

스타일 선택 패널 구현: src/components/StylePanel.tsx 파일을 생성한다. props로 nodeId, currentStyle, onClose를 받는다. interface StylePanelProps {nodeId: string; currentStyle: string; onClose: () => void;}를 정의한다. useState로 현재 조합을 관리한다. const [tokens, setTokens] = useState(currentStyle.split(' '))를 추가한다. useCanvasStore에서 tokenDefinitions와 updateNode를 가져온다. const {tokenDefinitions, updateNode} = useCanvasStore()를 추가한다. 토큰을 카테고리별로 분류한다. const colorTokens = Object.keys(tokenDefinitions).filter(k => k.startsWith('color-')); const sizeTokens = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']; const feelTokens = ['smooth', 'neat', 'rough', 'sketchy', 'messy']; const borderTokens = ['thin', 'normal', 'thick', 'bold']를 계산한다. 카테고리별로 버튼을 렌더링한다. div className="p-4 bg-white rounded-lg shadow-xl" 안에 각 카테고리를 div className="mb-4"로 감싸고 h3 className="text-sm font-bold mb-2"로 카테고리 제목을 표시한다. 각 토큰을 버튼으로 렌더링한다. button className="px-3 py-1 mr-2 rounded bg-gray-200 hover:bg-blue-500" onClick={() => toggleToken(token)}를 작성한다. toggleToken 함수를 구현한다. const toggleToken = (token: string) => {setTokens(prev => prev.includes(token) ? prev.filter(t => t !== token) : [...prev, token]); const newStyle = tokens.join(' '); updateNode(nodeId, {style: newStyle});}를 작성한다. 하단에 현재 조합을 표시한다. div className="mt-4 p-2 bg-gray-100 rounded" 안에 p className="text-sm text-gray-700"으로 현재: {tokens.join(' ')}를 표시한다. 외부 클릭 시 닫히도록 한다. useEffect(() => {const handleClick = () => onClose(); document.addEventListener('click', handleClick); return () => document.removeEventListener('click', handleClick);}, [])를 추가한다.

시작 화면 구현: src/components/StartScreen.tsx 파일을 생성한다. useCanvasStore에서 loadFile, recentFiles를 가져온다. const {loadFile, recentFiles} = useCanvasStore()를 추가한다. localStorage에서 최근 파일 목록을 로드한다. useEffect(() => {const stored = localStorage.getItem('knotly-recent-files'); if (stored) set({recentFiles: JSON.parse(stored)});}, [])를 canvasStore.ts에 추가한다. 새 노트 만들기 버튼을 렌더링한다. button className="w-64 py-4 bg-blue-500 text-white rounded-lg shadow-lg hover:bg-blue-600" onClick={handleNewNote}를 작성한다. handleNewNote 함수는 DEFAULT_TOKENS로 초기화한다. const handleNewNote = () => {set({tokenDefinitions: DEFAULT_TOKENS, nodes: [], edges: [], currentFilePath: null, hasUnsavedChanges: false}); navigate('/canvas');}를 작성한다. 파일 열기 버튼을 렌더링한다. button onClick={handleOpenFile}를 작성한다. handleOpenFile 함수는 openFile()을 호출한다. const handleOpenFile = async () => {const fileHandle = await openFile(); await loadFile(fileHandle); navigate('/canvas');}를 작성한다. 최근 파일 목록을 렌더링한다. div className="mt-8"로 감싸고 {recentFiles.map(path => <button key={path} onClick={() => handleOpenRecent(path)} className="block w-64 py-2 text-left hover:bg-gray-100">{path}</button>)}를 작성한다. 드래그 앤 드롭을 구현한다. div onDrop={handleDrop} onDragOver={(e) => e.preventDefault()} className="border-4 border-dashed border-gray-300 rounded-lg p-8"를 추가한다. handleDrop 함수는 dataTransfer.files[0]을 읽는다. const handleDrop = async (e: React.DragEvent) => {e.preventDefault(); const file = e.dataTransfer.files[0]; if (!file.name.endsWith('.knotly.md')) return; const text = await file.text(); // loadKnotlyFile 로직 실행}를 작성한다.

타이틀바 구현: src/components/TitleBar.tsx 파일을 생성한다. useCanvasStore에서 currentFilePath, hasUnsavedChanges, saveFile을 가져온다. const {currentFilePath, hasUnsavedChanges, saveFile} = useCanvasStore()를 추가한다. div className="fixed top-0 left-0 right-0 h-12 bg-white shadow flex items-center px-4"로 렌더링한다. 파일명을 표시한다. span className="text-sm font-medium"으로 {currentFilePath || '제목 없음'}를 표시한다. 저장 상태 표시를 추가한다. {hasUnsavedChanges ? <span className="ml-2 text-red-500">●</span> : <span className="ml-2 text-green-500">✓</span>}를 추가한다. Cmd+S 단축키를 구현한다. useEffect(() => {const handleKeyDown = (e: KeyboardEvent) => {if ((e.metaKey || e.ctrlKey) && e.key === 's') {e.preventDefault(); saveFile();}}; document.addEventListener('keydown', handleKeyDown); return () => document.removeEventListener('keydown', handleKeyDown);}, [saveFile])를 추가한다. 저장 버튼을 추가한다. button className="ml-auto px-4 py-1 bg-blue-500 text-white rounded" onClick={() => saveFile()}로 저장를 표시한다.

캔버스 더블클릭/터치 핸들러 구현: Canvas 컴포넌트에서 더블클릭 이벤트를 처리한다. SVG 요소에 onDoubleClick 이벤트를 추가한다. const handleDoubleClick = (e: React.MouseEvent<SVGSVGElement>) => {if (e.target !== e.currentTarget) return; const svgRect = e.currentTarget.getBoundingClientRect(); const x = (e.clientX - svgRect.left - pan.x) / zoom; const y = (e.clientY - svgRect.top - pan.y) / zoom; createNode({x, y});}를 작성한다. svg onDoubleClick={handleDoubleClick}를 추가한다. 모바일 더블터치를 처리한다. @use-gesture/react의 useTap 훅을 사용한다. const bind = useTap(({event, taps}) => {if (taps === 2) {const touch = event.touches[0]; const svgRect = svgRef.current.getBoundingClientRect(); const x = (touch.clientX - svgRect.left - pan.x) / zoom; const y = (touch.clientY - svgRect.top - pan.y) / zoom; createNode({x, y});}})를 작성하고 svg {...bind()}를 추가한다. createNode 액션을 수정하여 노드 생성 즉시 편집 모드로 전환하고 선택된 노드가 있으면 자동 연결한다. createNode: (position) => {const state = get(); const newNode = {id: v4(), position, content: '', style: 'color-yellow h4 neat', createdAt: Date.now(), updatedAt: Date.now()}; const newNodes = [...state.nodes, newNode]; const newEdges = state.selectedNodeId ? [...state.edges, {id: v4(), fromId: state.selectedNodeId, toId: newNode.id, lineStyle: 'dashed', createdAt: Date.now()}] : state.edges; set({nodes: newNodes, edges: newEdges, editingNodeId: newNode.id, selectedNodeId: newNode.id}); markDirty();}를 작성한다. selectedNodeId와 editingNodeId 필드를 Zustand store에 추가한다. selectedNodeId: string | null = null, editingNodeId: string | null = null과 setSelectedNode: (id: string | null) => set({selectedNodeId: id}), setEditingNode: (id: string | null) => set({editingNodeId: id})를 추가한다.

노드 연결 시스템 구현: 시나리오 1은 위의 createNode에서 처리되었다. 시나리오 2-데스크톱을 구현한다. NodeComponent에서 노드 가장자리 드래그를 처리한다. 노드 SVG circle 요소 위에 투명한 circle을 하나 더 그려 가장자리 영역을 만든다. circle r={resolvedStyle.width / 2} fill="transparent" stroke="transparent" strokeWidth={20} className="cursor-pointer"를 추가한다. 이 circle에 useDrag 훅을 별도로 적용한다. const edgeDragBind = useDrag(({first, last, xy}) => {if (first) {set({connectingFrom: node.id}); return;} if (last) {const targetNode = findNodeAtPosition(xy); if (targetNode && targetNode.id !== node.id) createEdge(node.id, targetNode.id); set({connectingFrom: null});}})를 작성한다. connectingFrom 필드를 Zustand store에 추가한다. connectingFrom: string | null = null을 추가한다. 드래그 중에 임시 선을 렌더링한다. Canvas 컴포넌트에서 connectingFrom이 null이 아니면 마우스 위치까지 점선을 그린다. const {connectingFrom, nodes} = useCanvasStore(); const [mousePos, setMousePos] = useState({x: 0, y: 0}); const handleMouseMove = (e) => {const svgRect = e.currentTarget.getBoundingClientRect(); setMousePos({x: (e.clientX - svgRect.left - pan.x) / zoom, y: (e.clientY - svgRect.top - pan.y) / zoom});}를 추가하고 svg onMouseMove={handleMouseMove}를 설정한다. connectingFrom이 있으면 임시 선을 렌더링한다. {connectingFrom && <line x1={fromNode.position.x} y1={fromNode.position.y} x2={mousePos.x} y2={mousePos.y} stroke="#999" strokeDasharray="5,5" />}를 추가한다. 시나리오 2-모바일을 구현한다. NodeComponent에서 useLongPress 훅을 사용한다. const longPressBind = useLongPress(() => {set({connectingFrom: node.id});}, {threshold: 500})를 작성하고 circle {...longPressBind()}를 추가한다. connectingFrom이 설정되면 노드 탭 시 연결을 생성한다. NodeComponent의 onClick 핸들러에서 const handleClick = () => {const {connectingFrom, createEdge} = useCanvasStore.getState(); if (connectingFrom && connectingFrom !== node.id) {createEdge(connectingFrom, node.id); set({connectingFrom: null});} else {set({selectedNodeId: node.id});}}를 작성한다. createEdge 액션을 Zustand store에 추가한다. createEdge: (fromId: string, toId: string) => {const exists = get().edges.some(e => (e.fromId === fromId && e.toId === toId) || (e.fromId === toId && e.toId === fromId)); if (exists) return; set(state => ({edges: [...state.edges, {id: v4(), fromId, toId, lineStyle: 'dashed', createdAt: Date.now()}]})); markDirty();}를 작성한다. EdgeComponent를 구현한다. src/components/EdgeComponent.tsx 파일을 생성한다. props로 edge를 받는다. useCanvasStore에서 nodes를 가져와 fromId와 toId로 노드를 찾는다. const fromNode = nodes.find(n => n.id === edge.fromId); const toNode = nodes.find(n => n.id === edge.toId); if (!fromNode || !toNode) return null를 체크한다. rough.js로 점선을 그린다. useEffect(() => {const rc = rough.svg(svgRef.current); const line = rc.line(fromNode.position.x, fromNode.position.y, toNode.position.x, toNode.position.y, {strokeLineDash: [5, 5], strokeWidth: 2, stroke: '#666', seed: edge.id.charCodeAt(0)}); svgRef.current.appendChild(line);}, [fromNode, toNode])를 작성한다. Canvas 컴포넌트에서 EdgeComponent를 렌더링한다. {edges.map(edge => <EdgeComponent key={edge.id} edge={edge} />)}를 추가한다.

라우팅 설정: src/App.tsx를 수정하여 시작 화면과 캔버스 화면을 조건부 렌더링한다. useState로 현재 화면을 관리한다. const [screen, setScreen] = useState<'start' | 'canvas'>('start')를 추가한다. useCanvasStore에서 nodes를 가져와 노드가 있으면 캔버스 화면으로 전환한다. const {nodes} = useCanvasStore(); useEffect(() => {if (nodes.length > 0) setScreen('canvas');}, [nodes])를 추가한다. 조건부 렌더링한다. {screen === 'start' ? <StartScreen onNavigate={() => setScreen('canvas')} /> : <><TitleBar /><Canvas /></>}를 작성한다.

기술적 제약사항: File System Access API는 Chromium 기반 브라우저만 지원한다. Safari, Firefox는 폴백으로 input type="file"과 Blob download를 사용한다. if ('showOpenFilePicker' in window) {...} else {...}로 분기한다. js-yaml의 dump() 메서드는 기본적으로 JSON과 유사한 형식으로 출력한다. flowLevel 옵션을 조정하여 가독성을 높인다. yaml.dump(frontmatter, {flowLevel: 2})로 중첩된 객체는 인라인으로 표시한다. 토큰 파서는 순수 함수로 구현하여 테스트 가능하게 한다. 재귀 파싱 시 무한 루프를 방지하기 위해 깊이 제한을 둔다. let depth = 0; if (depth > 10) throw new Error('Token recursion too deep')를 추가한다. 스타일 선택 패널은 모달 오버레이로 구현하지 않고 노드 옆에 포지셔닝한다. position: absolute를 사용하여 노드 위치 기준으로 배치한다. rough.js의 seed 옵션을 사용하여 동일한 노드는 항상 동일한 모양으로 렌더링되도록 한다. seed: node.id.charCodeAt(0)로 설정한다. 노드 크기는 토큰에서 width, height를 가져오지만 텍스트가 넘치면 자동으로 늘어나도록 한다. SVG foreignObject를 사용하여 HTML div로 텍스트를 렌더링하고 overflow: auto를 설정한다.

참고 자료: File System Access API 문서 https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API에서 showOpenFilePicker, showSaveFilePicker, createWritable 메서드를 확인한다. js-yaml 공식 문서 https://github.com/nodeca/js-yaml에서 load와 dump 메서드 옵션을 확인한다. dump의 flowLevel 옵션으로 출력 형식을 제어할 수 있다. Zustand의 get() 함수는 store 외부에서 현재 상태를 읽을 때 사용한다. 액션 내부에서 다른 액션을 호출할 때 유용하다. const state = get()로 현재 상태를 가져온다. rough.js의 seed 옵션은 난수 생성의 시드 값으로, 동일한 seed는 동일한 결과를 생성한다. 노드 ID를 해시하여 seed로 사용한다. SVG foreignObject는 HTML 요소를 SVG 안에 렌더링할 수 있게 한다. foreignObject x={0} y={0} width={width} height={height}로 영역을 지정하고 내부에 div를 렌더링한다. localStorage는 최대 5MB까지 저장 가능하므로 최근 파일 목록은 파일 경로만 저장하고 내용은 저장하지 않는다.
