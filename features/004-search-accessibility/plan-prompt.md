기술 스택: React 18과 TypeScript를 사용한다. lodash.debounce를 검색 디바운싱에 사용한다. Tailwind CSS의 focus-visible 플러그인을 포커스 스타일링에 사용한다. @tailwindcss/forms 플러그인을 설치하여 접근성 친화적인 폼 스타일을 적용한다. react-hotkeys-hook 라이브러리를 설치하여 키보드 단축키를 선언적으로 관리한다. pnpm add react-hotkeys-hook을 실행한다. Fuse.js 라이브러리를 설치하여 퍼지 검색을 지원한다. pnpm add fuse.js를 실행한다. WAVE 브라우저 확장을 설치하여 접근성을 테스트한다. Chrome 또는 Firefox에서 WAVE Evaluation Tool을 설치한다. NVDA 스크린 리더를 Windows에서 다운로드하거나 macOS의 내장 VoiceOver를 사용한다.

아키텍처 개요: SearchModal 컴포넌트를 만들고 전역 키보드 리스너로 Cmd+K 입력 시 표시한다. Zustand 스토어에 searchModalOpen: boolean 상태를 추가한다. KeyboardShortcuts 훅을 만들어 react-hotkeys-hook으로 모든 단축키를 등록한다. AccessibilityProvider 컨텍스트를 만들어 aria-live 영역을 관리한다. 노드 추가/삭제 시 announceToScreenReader(message: string) 함수를 호출하여 메시지를 업데이트한다. HighContrastModeProvider 컨텍스트를 만들어 고대비 모드 상태를 관리하고 CSS 변수를 동적으로 변경한다. FocusManager 클래스를 만들어 Tab 키로 포커스 이동 순서를 관리한다.

Zustand 스토어 검색 및 접근성 상태 확장. src/store/canvasStore.ts를 수정한다. searchModalOpen: boolean을 추가한다. focusedNodeId: string | null을 추가한다. highlightedNodeId: string | null을 추가한다. highContrastMode: boolean을 추가한다. openSearchModal: () => void 액션을 추가하여 set({searchModalOpen: true})를 실행한다. closeSearchModal: () => void 액션을 추가하여 set({searchModalOpen: false})를 실행한다. setFocusedNode: (id: string | null) => void 액션을 추가한다. setHighlightedNode: (id: string | null) => void 액션을 추가하고, setTimeout(() => set({highlightedNodeId: null}), 3000)를 내부에서 실행한다. panToNode: (id: string) => void 액션을 추가한다. const node = get().nodes.find(n => n.id === id)를 찾는다. if (!node) return으로 early return한다. set({pan: {x: -node.position.x + window.innerWidth / 2, y: -node.position.y + window.innerHeight / 2}, zoom: 1.5, highlightedNodeId: id})를 실행한다. toggleHighContrastMode: () => void 액션을 추가하여 set((state) => ({highContrastMode: !state.highContrastMode}))를 실행한다.

SearchModal 컴포넌트 구현. src/components/SearchModal.tsx 파일을 생성한다. import { useCanvasStore } from '../store/canvasStore'를 추가한다. import debounce from 'lodash.debounce'를 추가한다. import { useMemo, useState, useEffect, useRef } from 'react'를 추가한다. const searchModalOpen = useCanvasStore((state) => state.searchModalOpen)으로 상태를 구독한다. const closeSearchModal = useCanvasStore((state) => state.closeSearchModal)로 액션을 가져온다. const nodes = useCanvasStore((state) => state.nodes)로 노드 목록을 가져온다. const [query, setQuery] = useState('')로 검색어 상태를 관리한다. const [results, setResults] = useState([])로 결과 상태를 관리한다. const inputRef = useRef<HTMLInputElement>(null)로 입력창 참조를 만든다. useEffect(() => { if (searchModalOpen && inputRef.current) { inputRef.current.focus(); } }, [searchModalOpen])를 추가하여 모달 열릴 때 자동 포커스한다. const debouncedSearch = useMemo(() => debounce((q: string) => { const filtered = nodes.filter(n => n.content.toLowerCase().includes(q.toLowerCase())); setResults(filtered.sort((a, b) => b.createdAt - a.createdAt)); }, 200), [nodes])를 정의한다. const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => { const value = e.target.value; setQuery(value); debouncedSearch(value); }를 구현한다. const handleResultClick = (nodeId: string) => { useCanvasStore.getState().panToNode(nodeId); closeSearchModal(); }를 구현한다. 렌더링은 {searchModalOpen && <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={closeSearchModal}><div className="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-96 flex flex-col" onClick={(e) => e.stopPropagation()}><input ref={inputRef} type="text" value={query} onChange={handleChange} className="p-4 border-b" placeholder="노드 검색... (Cmd+K)" aria-label="노드 검색" /><div className="overflow-y-auto flex-1">{results.length === 0 && query && <p className="p-4 text-gray-500">검색 결과가 없습니다</p>}{results.map(node => <div key={node.id} onClick={() => handleResultClick(node.id)} className="p-4 hover:bg-gray-100 cursor-pointer border-b"><p className="font-medium" dangerouslySetInnerHTML={{__html: highlightQuery(node.content, query)}} /><p className="text-xs text-gray-500">{new Date(node.createdAt).toLocaleString()}</p></div>)}</div></div></div>}로 작성한다. highlightQuery 함수를 정의하여 const regex = new RegExp(`(${query})`, 'gi'); return content.replace(regex, '<strong>$1</strong>')를 실행한다.

구현 순서 3단계: 키보드 단축키를 등록한다. pnpm add react-hotkeys-hook을 설치한다. src/hooks/useKeyboardShortcuts.ts 파일을 생성한다. import { useHotkeys } from 'react-hotkeys-hook'를 추가한다. import { useCanvasStore } from '../store/canvasStore'를 추가한다. export const useKeyboardShortcuts = () => 훅을 정의한다. useHotkeys('cmd+k, ctrl+k', (e) => { e.preventDefault(); useCanvasStore.getState().openSearchModal(); }, {enableOnFormTags: false})를 등록한다. enableOnFormTags: false는 input, textarea에서 단축키를 비활성화한다. useHotkeys('n', (e) => { e.preventDefault(); const centerX = window.innerWidth / 2; const centerY = window.innerHeight / 2; useCanvasStore.getState().createNode(centerX, centerY, ''); }, {enableOnFormTags: false})를 등록한다. useHotkeys('enter', (e) => { const focusedNodeId = useCanvasStore.getState().focusedNodeId; if (focusedNodeId) { e.preventDefault(); useCanvasStore.getState().startEditingNode(focusedNodeId); } }, {enableOnFormTags: false})를 등록한다. useHotkeys('backspace', (e) => { const focusedNodeId = useCanvasStore.getState().focusedNodeId; if (focusedNodeId) { e.preventDefault(); useCanvasStore.getState().openDeleteConfirmModal(focusedNodeId); } }, {enableOnFormTags: false})를 등록한다. useHotkeys('tab', (e) => { e.preventDefault(); const nodes = useCanvasStore.getState().nodes; const focusedNodeId = useCanvasStore.getState().focusedNodeId; const currentIndex = nodes.findIndex(n => n.id === focusedNodeId); const nextIndex = (currentIndex + 1) % nodes.length; useCanvasStore.getState().setFocusedNode(nodes[nextIndex]?.id || null); }, {enableOnFormTags: false})를 등록한다. useHotkeys('shift+tab', (e) => { e.preventDefault(); const nodes = useCanvasStore.getState().nodes; const focusedNodeId = useCanvasStore.getState().focusedNodeId; const currentIndex = nodes.findIndex(n => n.id === focusedNodeId); const prevIndex = currentIndex - 1 < 0 ? nodes.length - 1 : currentIndex - 1; useCanvasStore.getState().setFocusedNode(nodes[prevIndex]?.id || null); }, {enableOnFormTags: false})를 등록한다. useHotkeys('escape', (e) => { e.preventDefault(); useCanvasStore.getState().closeSearchModal(); useCanvasStore.getState().closeCheatSheet(); }, {enableOnFormTags: true})를 등록한다. Esc는 모달 닫기이므로 enableOnFormTags: true로 설정한다. useHotkeys('shift+/', (e) => { e.preventDefault(); useCanvasStore.getState().openCheatSheet(); }, {enableOnFormTags: false})를 등록한다. ? 키는 shift+/로 입력된다. App.tsx에서 useKeyboardShortcuts()를 호출하여 전역으로 등록한다.

구현 순서 4단계: CheatSheet 컴포넌트를 구현한다. src/components/CheatSheet.tsx 파일을 생성한다. const shortcuts = [{key: 'N', description: '새 노드 생성', category: '노드 편집'}, {key: 'Enter', description: '편집 모드 진입', category: '노드 편집'}, {key: 'Backspace', description: '노드 삭제', category: '노드 편집'}, {key: 'Cmd+K', description: '검색 모달 열기', category: '검색'}, {key: 'Tab', description: '다음 노드로 이동', category: '탐색'}, {key: 'Shift+Tab', description: '이전 노드로 이동', category: '탐색'}, {key: 'Esc', description: '모달 닫기', category: '기타'}, {key: '?', description: '단축키 도움말', category: '기타'}]를 정의한다. const groupedShortcuts = useMemo(() => { return shortcuts.reduce((acc, shortcut) => { if (!acc[shortcut.category]) acc[shortcut.category] = []; acc[shortcut.category].push(shortcut); return acc; }, {} as Record<string, typeof shortcuts>); }, [])를 정의하여 카테고리별로 그룹화한다. 렌더링은 <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"><div className="bg-white rounded-lg shadow-xl w-full max-w-2xl p-6"><h2 className="text-2xl font-bold mb-4">키보드 단축키</h2>{Object.entries(groupedShortcuts).map(([category, shortcuts]) => <div key={category} className="mb-4"><h3 className="text-lg font-semibold mb-2">{category}</h3><table className="w-full"><tbody>{shortcuts.map(s => <tr key={s.key}><td className="py-1 pr-4"><kbd className="px-2 py-1 bg-gray-200 rounded">{s.key}</kbd></td><td className="py-1">{s.description}</td></tr>)}</tbody></table></div>)}</div></div>로 작성한다.

구현 순서 5단계: 접근성 속성을 추가한다. src/components/Node.tsx 파일을 수정한다. <g role="article" aria-label={`노드: ${node.content}`} tabIndex={0} data-node-id={node.id}>로 래핑한다. tabIndex={0}을 추가하여 키보드 포커스를 가능하게 한다. onFocus={() => useCanvasStore.getState().setFocusedNode(node.id)} 이벤트를 추가한다. const isFocused = useCanvasStore((state) => state.focusedNodeId === node.id)로 포커스 상태를 구독한다. {isFocused && <rect x={node.position.x - 10} y={node.position.y - 10} width="20" height="20" fill="none" stroke="#3B82F6" strokeWidth="2" rx="4" />}로 포커스 outline을 SVG로 렌더링한다. FAB 버튼에 aria-label="새 노드 추가"를 추가한다. <button className="..." aria-label="새 노드 추가">+</button>로 작성한다. SearchModal의 input에 aria-label="노드 검색"을 추가한다. 이미 2단계에서 추가했으므로 확인만 한다.

구현 순서 6단계: aria-live 영역을 추가한다. src/components/AccessibilityAnnouncer.tsx 파일을 생성한다. const nodes = useCanvasStore((state) => state.nodes)로 노드 배열을 구독한다. const edges = useCanvasStore((state) => state.edges)로 엣지 배열을 구독한다. const [announcement, setAnnouncement] = useState('')로 알림 상태를 관리한다. useEffect(() => { setAnnouncement(`${nodes.length}개의 노드, ${edges.length}개의 엣지`); }, [nodes.length, edges.length])를 추가하여 노드/엣지 수 변경 시 알림을 업데이트한다. 렌더링은 <div role="status" aria-live="polite" aria-atomic="true" className="sr-only">{announcement}</div>로 작성한다. sr-only는 Tailwind 클래스로 position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0을 적용한다. App.tsx에서 <AccessibilityAnnouncer />를 렌더링한다. Zustand 스토어에 announceToScreenReader: (message: string) => void 액션을 추가한다. AccessibilityAnnouncer 컴포넌트에서 useEffect(() => { const unsubscribe = useCanvasStore.subscribe((state) => state.announcement, (announcement) => { setAnnouncement(announcement); }); return unsubscribe; }, [])로 구독한다. createNode, deleteNode 액션에서 useCanvasStore.getState().announceToScreenReader('노드가 추가되었습니다') 또는 announceToScreenReader('노드가 삭제되었습니다')를 호출한다.

구현 순서 7단계: 고대비 모드를 구현한다. src/index.css 파일을 수정한다. :root { --bg-color: #fafafa; --node-border: #000; --text-color: #333; --node-stroke-width: 2px; }를 추가한다. :root[data-high-contrast="true"] { --bg-color: #000000; --node-border: #FFFFFF; --text-color: #FFFFFF; --node-stroke-width: 3px; }를 추가한다. Canvas.tsx에서 <rect x="0" y="0" width={width} height={height} fill="var(--bg-color)" />로 배경색을 CSS 변수로 설정한다. Node.tsx에서 rough.js의 stroke 옵션을 const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--node-border')로 가져와서 사용한다. const strokeWidth = Number(getComputedStyle(document.documentElement).getPropertyValue('--node-stroke-width').replace('px', ''))로 가져온다. rc.circle(..., {stroke: strokeColor, strokeWidth})로 렌더링한다. src/components/Settings.tsx 파일을 생성한다. const highContrastMode = useCanvasStore((state) => state.highContrastMode)로 상태를 구독한다. const toggleHighContrastMode = useCanvasStore((state) => state.toggleHighContrastMode)로 액션을 가져온다. <label className="flex items-center"><input type="checkbox" checked={highContrastMode} onChange={toggleHighContrastMode} className="mr-2" /><span>고대비 모드</span></label>로 토글을 렌더링한다. useEffect(() => { document.documentElement.setAttribute('data-high-contrast', highContrastMode ? 'true' : 'false'); }, [highContrastMode])를 추가하여 data 속성을 동적으로 설정한다. useEffect(() => { const mediaQuery = window.matchMedia('(prefers-contrast: high)'); if (mediaQuery.matches) { useCanvasStore.getState().toggleHighContrastMode(); } const handleChange = (e: MediaQueryListEvent) => { if (e.matches) useCanvasStore.getState().toggleHighContrastMode(); }; mediaQuery.addEventListener('change', handleChange); return () => mediaQuery.removeEventListener('change', handleChange); }, [])를 추가하여 시스템 설정을 감지한다.

구현 순서 8단계: 포커스 스타일을 추가한다. tailwind.config.js를 수정한다. plugins: [require('@tailwindcss/forms')]를 추가한다. pnpm add @tailwindcss/forms를 먼저 설치한다. variants: {extend: {outline: ['focus-visible']}}를 추가한다. src/index.css에 *:focus-visible { outline: 2px solid #3B82F6; outline-offset: 2px; border-radius: 4px; }를 추가한다. *:focus:not(:focus-visible) { outline: none; }를 추가하여 마우스 클릭 시에는 outline을 표시하지 않는다. Node.tsx의 포커스 outline을 제거하고 CSS로 통일한다. 이전에 SVG로 렌더링한 rect를 제거하고 className에 focus-visible:outline-blue-500를 추가한다. 하지만 SVG 요소는 Tailwind focus-visible이 적용되지 않으므로 CSS :focus-visible 의사 클래스를 직접 사용한다. g:focus-visible { outline: 2px solid #3B82F6; outline-offset: 2px; }를 index.css에 추가한다.

구현 순서 9단계: 검색 성능을 최적화한다. 노드 수가 1000개 이상이면 Fuse.js를 사용하여 퍼지 검색을 수행한다. pnpm add fuse.js를 설치한다. SearchModal.tsx를 수정한다. import Fuse from 'fuse.js'를 추가한다. const fuse = useMemo(() => new Fuse(nodes, {keys: ['content'], threshold: 0.3, includeScore: true}), [nodes])를 정의한다. threshold: 0.3은 퍼지 매칭의 엄격도를 설정한다. 0.0은 완전 일치, 1.0은 모든 것을 매칭한다. const debouncedSearch = useMemo(() => debounce((q: string) => { if (nodes.length > 1000) { const fuseResults = fuse.search(q); setResults(fuseResults.map(r => r.item).sort((a, b) => b.createdAt - a.createdAt)); } else { const filtered = nodes.filter(n => n.content.toLowerCase().includes(q.toLowerCase())); setResults(filtered.sort((a, b) => b.createdAt - a.createdAt)); } }, 200), [nodes, fuse])로 수정한다. 이는 노드 수에 따라 검색 방식을 동적으로 선택한다.

구현 순서 10단계: 접근성 테스트를 수행한다. WAVE 브라우저 확장을 사용하여 페이지를 평가한다. Chrome에서 페이지를 열고 WAVE 아이콘을 클릭한다. Errors 섹션에 에러가 있는지 확인한다. Missing form label 에러가 있으면 input에 aria-label을 추가한다. Missing alternative text 에러가 있으면 img에 alt 속성을 추가한다. Contrast errors 에러가 있으면 색상 대비를 조정한다. NVDA 스크린 리더로 테스트한다. Windows에서 NVDA를 실행한다. Ctrl+Alt+N으로 시작한다. Insert+Down Arrow로 페이지를 읽는다. Tab 키로 인터랙티브 요소를 탐색한다. FAB 버튼에 도달하면 "새 노드 추가 버튼"을 읽는지 확인한다. 노드에 도달하면 "노드: 프로젝트 아이디어"를 읽는지 확인한다. 검색 모달을 열고 입력창에 도달하면 "노드 검색 편집 창"을 읽는지 확인한다. VoiceOver로 macOS에서 테스트한다. Cmd+F5로 VoiceOver를 활성화한다. Ctrl+Option+Right Arrow로 요소를 탐색한다. WebAIM Contrast Checker로 대비율을 측정한다. https://webaim.org/resources/contrastchecker/에 접속한다. Foreground Color에 텍스트 색상 #333을 입력한다. Background Color에 배경색 #fafafa를 입력한다. Contrast Ratio가 4.5:1 이상인지 확인한다. 고대비 모드에서 #FFFFFF와 #000000을 입력하여 21:1을 확인한다.

기술적 제약사항: react-hotkeys-hook은 전역 리스너를 등록하므로 키 충돌이 발생할 수 있다. 브라우저 기본 단축키(Cmd+R, Cmd+T 등)는 오버라이드하지 않는다. enableOnFormTags: false로 설정하여 입력 중에는 단축키를 비활성화한다. Fuse.js는 노드 수가 적을 때는 오히려 느릴 수 있으므로 1000개 기준으로 조건부 사용한다. SVG 요소는 Tailwind CSS의 focus-visible 유틸리티가 적용되지 않으므로 CSS :focus-visible 의사 클래스를 직접 사용한다. aria-live="polite"는 스크린 리더가 현재 읽고 있는 내용을 끝낸 후 알림을 읽는다. aria-live="assertive"는 즉시 중단하고 알림을 읽지만 사용자 경험이 나쁘므로 사용하지 않는다. dangerouslySetInnerHTML은 XSS 공격에 취약하므로 검색어를 escape 처리해야 한다. highlightQuery 함수에서 const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')로 이스케이프한다. Constitution 원칙에 따라 throw를 사용하지 않는다. 노드를 찾지 못했을 때 panToNode에서 early return한다. prefers-contrast 미디어 쿼리는 모든 브라우저에서 지원되지 않으므로 폴백을 제공한다.

참고 자료: WCAG 2.1 가이드라인 https://www.w3.org/WAI/WCAG21/quickref/에서 AA 레벨 요구사항을 확인한다. 1.4.3 Contrast (Minimum)는 텍스트 대비율 4.5:1을 요구한다. 2.1.1 Keyboard는 모든 기능이 키보드로 접근 가능해야 한다고 명시한다. react-hotkeys-hook 공식 문서 https://react-hotkeys-hook.vercel.app/에서 useHotkeys API를 확인한다. enableOnFormTags, enableOnContentEditable 옵션을 확인한다. Fuse.js 공식 문서 https://fusejs.io/에서 threshold, keys, includeScore 옵션을 확인한다. ARIA Authoring Practices Guide https://www.w3.org/WAI/ARIA/apg/에서 role, aria-label, aria-live 사용법을 확인한다. WAVE 웹 접근성 평가 도구 https://wave.webaim.org/extension/에서 브라우저 확장을 다운로드한다. NVDA 스크린 리더 https://www.nvaccess.org/download/에서 무료로 다운로드한다. WebAIM Contrast Checker https://webaim.org/resources/contrastchecker/에서 대비율을 측정한다. Tailwind CSS focus-visible 문서 https://tailwindcss.com/docs/focus-visible에서 사용법을 확인한다. CSS :focus-visible 의사 클래스 https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible에서 브라우저 호환성을 확인한다.
