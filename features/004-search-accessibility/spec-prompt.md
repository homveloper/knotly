목표: 전체 텍스트 검색, 키보드 단축키, WCAG 2.1 AA 레벨 접근성을 구현하여 생산성과 포용성을 개선한다. Cmd+K로 검색 모달을 열고, 키보드만으로 모든 작업을 수행할 수 있으며, 스크린 리더로 모든 콘텐츠에 접근할 수 있도록 한다.

핵심 기능: 전체 텍스트 검색. Cmd+K(macOS) 또는 Ctrl+K(Windows/Linux)를 눌러 검색 모달을 연다. 입력창에 텍스트를 입력하면 200ms 디바운싱 후 Zustand 스토어의 nodes 배열을 필터링한다. 필터링은 node.content.toLowerCase().includes(query.toLowerCase())로 대소문자 무시 검색을 수행한다. 검색 결과는 생성일 내림차순으로 정렬하여 최신 노드를 먼저 표시한다. 각 결과 항목은 노드 ID, 내용 미리보기(최대 100자), 생성일을 표시한다. 검색어는 볼드 처리하여 하이라이트한다. 결과를 클릭하면 캔버스가 해당 노드 중앙으로 팬(이동)하고, 줌 레벨을 1.5로 설정하며, 노드를 3초간 노란색 배경(#FFEB3B, opacity 0.6)으로 하이라이트한다. 하이라이트는 setTimeout으로 3초 후 제거한다. 키보드 단축키. N 키를 누르면 캔버스 중앙에 새 노드를 생성하고 즉시 편집 모드로 진입한다. Enter 키를 누르면 현재 선택된(포커스된) 노드를 편집 모드로 전환한다. Backspace 키를 누르면 선택된 노드를 삭제하되, 확인 모달을 먼저 표시한다. Tab 키를 누르면 다음 노드로 포커스를 이동한다. Shift+Tab은 이전 노드로 이동한다. Esc 키를 누르면 열린 모달을 닫거나 편집 모드를 종료한다. ? 키를 누르면 단축키 치트시트 모달을 표시한다. 단축키는 document.addEventListener('keydown')으로 전역 리스너를 등록하되, input이나 textarea에 포커스가 있을 때는 무시한다. if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return을 체크한다. 접근성. 모든 노드에 role="article" 속성을 추가한다. 노드 내용을 aria-label="노드: {content}"로 제공한다. FAB 버튼에 aria-label="새 노드 추가"를 추가한다. 검색 모달 입력창에 aria-label="노드 검색"을 추가한다. 모든 인터랙티브 요소(버튼, 링크)에 tabindex="0"을 설정하여 키보드 탐색을 가능하게 한다. 포커스 시 outline: 2px solid #3B82F6; outline-offset: 2px를 적용한다. 스크린 리더용 숨김 텍스트는 sr-only Tailwind 클래스를 사용한다. 캔버스 상단에 role="status" aria-live="polite"로 "노드 5개, 엣지 3개"와 같은 요약 정보를 제공한다. 노드 추가/삭제 시 이 정보를 업데이트한다. 고대비 모드. Zustand 스토어에 highContrastMode: boolean 상태를 추가한다. 설정 패널에 토글 버튼을 제공한다. 활성화 시 CSS 변수를 변경한다. --bg-color: #000000, --node-border: #FFFFFF, --text-color: #FFFFFF, --node-stroke-width: 3px로 설정한다. rough.js의 stroke 옵션을 --node-border 변수로 동적으로 설정한다. window.matchMedia('(prefers-contrast: high)')로 시스템 설정을 감지하여 자동 활성화한다.

입출력 명세: 검색 입력. 사용자가 Cmd+K를 누르면 SearchModal 컴포넌트가 마운트되고 입력창에 자동 포커스된다. input 요소의 value는 useState로 관리한다. onChange 이벤트에서 lodash.debounce(handleSearch, 200)를 호출하여 200ms 디바운싱을 적용한다. handleSearch는 const filtered = nodes.filter(node => node.content.toLowerCase().includes(query.toLowerCase()))를 실행하고, setResults(filtered.sort((a, b) => b.createdAt - a.createdAt))로 상태를 업데이트한다. 검색 결과 클릭. 사용자가 결과 항목을 클릭하면 onClick 핸들러가 실행된다. useCanvasStore.getState().panToNode(nodeId)를 호출하여 캔버스를 이동한다. panToNode 액션은 const node = nodes.find(n => n.id === nodeId)를 찾고, setPan({x: -node.position.x + window.innerWidth / 2, y: -node.position.y + window.innerHeight / 2})로 팬을 설정한다. setZoom(1.5)로 줌 레벨을 조정한다. setHighlightedNode(nodeId)로 하이라이트 상태를 설정한다. setTimeout(() => setHighlightedNode(null), 3000)으로 3초 후 제거한다. 키보드 단축키 입력. document.addEventListener('keydown', (e) => {...})를 등록한다. e.key === 'k' && (e.metaKey || e.ctrlKey)를 체크하여 Cmd+K 또는 Ctrl+K를 감지한다. e.key === 'n'을 체크하여 N 키를 감지한다. e.key === 'Enter'를 체크하여 Enter 키를 감지한다. e.key === 'Backspace'를 체크하여 Backspace 키를 감지한다. e.key === 'Tab'을 체크하여 Tab 키를 감지한다. e.shiftKey를 체크하여 Shift+Tab을 구분한다. e.key === 'Escape'를 체크하여 Esc 키를 감지한다. e.key === '?'를 체크하여 ? 키를 감지한다. 단축키 처리 시 e.preventDefault()를 호출하여 브라우저 기본 동작을 방지한다. 포커스 이동. Tab 키 입력 시 const focusableNodes = nodes.filter(n => !n.deleted)를 가져온다. const currentIndex = focusableNodes.findIndex(n => n.id === focusedNodeId)를 찾는다. const nextIndex = (currentIndex + 1) % focusableNodes.length를 계산한다. setFocusedNode(focusableNodes[nextIndex].id)를 설정한다. 포커스된 노드는 CSS :focus-visible 또는 data-focused 속성으로 스타일링한다. 접근성 정보 출력. aria-live 영역에 표시할 텍스트는 `${nodes.length}개의 노드, ${edges.length}개의 엣지`로 구성한다. 노드 추가 시 "노드가 추가되었습니다"를 aria-live 영역에 업데이트한다. 노드 삭제 시 "노드가 삭제되었습니다"를 업데이트한다. 스크린 리더가 이를 읽어준다.

데이터 구조: 검색 결과는 {id: UUID, content: string, createdAt: number, preview: string} 배열로 관리한다. preview는 content.substring(0, 100)으로 생성한다. 포커스 상태는 Zustand 스토어에 focusedNodeId: UUID | null로 관리한다. 하이라이트 상태는 highlightedNodeId: UUID | null로 관리한다. 고대비 모드는 highContrastMode: boolean로 관리한다. 키보드 단축키 설정은 {key: string, description: string, category: string}[] 배열로 정의한다. 예시: [{key: 'N', description: '새 노드 생성', category: '노드 편집'}, {key: 'Enter', description: '편집 모드 진입', category: '노드 편집'}, {key: 'Cmd+K', description: '검색 모달 열기', category: '검색'}, {key: 'Tab', description: '다음 노드로 이동', category: '탐색'}]. 치트시트 모달은 이 배열을 카테고리별로 그룹화하여 렌더링한다.

기능적 제약사항: 검색은 클라이언트 로컬 상태에서만 수행한다. 서버 검색은 구현하지 않으므로 노드 수가 수천 개를 초과하면 성능이 저하될 수 있다. Phase 2에서 서버 기반 전체 텍스트 검색을 PostgreSQL의 to_tsvector와 to_tsquery로 구현한다. 정규표현식 검색은 지원하지 않는다. Phase 2에서 추가한다. 검색 히스토리는 저장하지 않는다. 키보드 단축키는 영문 키보드 레이아웃만 고려한다. 한글 입력 모드에서는 일부 단축키가 작동하지 않을 수 있다. 스크린 리더 테스트는 NVDA(Windows), VoiceOver(macOS), JAWS(Windows)로 수행한다. ChromeVox는 테스트하지 않는다. 다국어 접근성은 지원하지 않는다. aria-label은 모두 한국어로 작성한다. Phase 2에서 i18n 추가 후 영어, 일본어를 지원한다.

기술적 제약: 검색 필터링은 Array.prototype.filter를 사용한다. 노드 수가 1000개 이상이면 성능을 위해 Fuse.js 라이브러리를 고려한다. 디바운싱은 lodash.debounce를 사용한다. 키보드 이벤트 리스너는 useEffect에서 등록하고 cleanup 함수에서 제거한다. 포커스 관리는 ref.current.focus()로 직접 제어한다. Tailwind CSS의 focus:outline-blue-500 같은 유틸리티를 사용하되, :focus-visible 의사 클래스를 함께 사용하여 마우스 클릭 시에는 outline을 표시하지 않는다. 고대비 모드는 CSS 변수를 :root[data-high-contrast="true"]로 조건부 설정한다. rough.js의 stroke 옵션은 getComputedStyle(document.documentElement).getPropertyValue('--node-border')로 동적으로 가져온다. aria-live 영역은 position: absolute; left: -9999px로 화면 밖에 숨긴다. role="status" aria-live="polite"로 설정하여 스크린 리더가 변경사항을 읽어준다.

의존성: Milestone 2의 Zustand 스토어가 구현되어 있어야 한다. nodes와 edges 배열이 있어야 검색이 가능하다. Milestone 3의 실시간 협업이 완료되어 있으면 검색 결과도 실시간으로 업데이트된다. lodash.debounce가 이미 설치되어 있으므로 재사용한다. Tailwind CSS 설정에서 focus-visible 플러그인을 활성화해야 한다. tailwind.config.js의 variants에 focusVisible: ['responsive']를 추가한다.

완료 조건: 브라우저에서 Cmd+K를 누르면 검색 모달이 화면 중앙에 나타난다. 입력창에 자동으로 포커스가 이동한다. "프로젝트"를 입력하면 200ms 디바운싱 후 해당 단어가 포함된 노드 목록이 표시된다. 검색어가 볼드 처리되어 하이라이트된다. 결과를 클릭하면 캔버스가 해당 노드로 이동하고 줌 레벨이 1.5로 설정된다. 노드가 3초간 노란색으로 하이라이트된다. N 키를 누르면 캔버스 중앙에 새 노드가 생성되고 편집 모드로 진입한다. Tab 키를 누르면 다음 노드로 포커스가 이동하고 파란색 outline이 표시된다. Enter 키를 누르면 포커스된 노드가 편집 모드로 전환된다. Backspace 키를 누르면 확인 모달이 표시되고, 확인 시 노드가 삭제된다. ? 키를 누르면 단축키 치트시트 모달이 표시된다. Esc 키를 누르면 모달이 닫힌다. NVDA 스크린 리더로 테스트하면 "노드 5개, 엣지 3개"를 읽어준다. FAB 버튼에 포커스하면 "새 노드 추가 버튼"을 읽어준다. 노드에 포커스하면 "노드: 프로젝트 아이디어"를 읽어준다. 고대비 모드를 활성화하면 배경이 검은색, 노드 테두리가 흰색으로 변경된다.

성공 지표: 사용자 5명에게 마우스 없이 키보드만으로 노드 10개를 작성하고 검색하는 테스트를 수행한다. 평균 완료 시간이 3분 이내이고, "키보드만으로 충분하다"는 피드백이 80% 이상이면 성공이다. 스크린 리더 사용자 2명에게 테스트를 수행하고, "내용을 이해할 수 있다"는 피드백이 100%이면 성공이다. WAVE 웹 접근성 평가 도구로 테스트하여 에러 0개, 경고 2개 이하이면 성공이다. 고대비 모드에서 WebAIM Contrast Checker로 대비율을 측정하여 7:1 이상이면 성공이다.
